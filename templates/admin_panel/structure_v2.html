<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–°—Ç—Ä—É–∫—Ç—É—Ä–∞ v2 ‚Äî –°–µ—Ç–∫–∞, –ø–∞–Ω–æ—Ä–∞–º–∏—Ä–æ–≤–∞–Ω–∏–µ, –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏–µ</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; color: #1f2937; }
        .toolbar { position: fixed; top: 10px; left: 10px; z-index: 1000; display: flex; align-items: center; gap: 8px; }
        .zoom-controls { display: flex; gap: 6px; }
        .zoom-btn { width: 36px; justify-content: center; padding: 6px 0; font-size: 18px; line-height: 1; }
        .menu-dropdown { display: none; position: absolute; top: calc(100% + 8px); left: 0; background: white; border-radius: 8px; box-shadow: 0 4px 20px rgba(0,0,0,0.15); min-width: 250px; max-height: 80vh; overflow-y: auto; padding: 12px; border: 1px solid #e5e7eb; }
        .menu-dropdown.show { display: block; }
        .menu-section { margin-bottom: 16px; }
        .menu-section:last-child { margin-bottom: 0; }
        .menu-title { font-size: 11px; font-weight: 600; color: #666; text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 8px; padding-bottom: 6px; border-bottom: 1px solid #e5e7eb; }
        .menu-btn { width: 100%; margin-bottom: 6px; text-align: left; justify-content: flex-start; padding: 8px 12px; }
        .menu-btn:last-child { margin-bottom: 0; }
        .menu-btn:hover { background: #f3f4f6; }
        .stats-panel { position: fixed; top: 10px; right: 10px; z-index: 1000; background: rgba(255,255,255,0.95); padding: 12px 16px; border-radius: 8px; box-shadow: 0 2px 12px rgba(0,0,0,0.1); min-width: 200px; }
        .stats-panel.collapsed { padding-bottom: 12px; }
        .stats-panel.collapsed #statsContent { display: none; }
        .stats-title { font-weight: 600; margin-bottom: 8px; font-size: 14px; color: #333; padding-right: 32px; }
        .stats-item { display: flex; justify-content: space-between; padding: 4px 0; font-size: 13px; border-bottom: 1px solid #eee; }
        .stats-item:last-child { border-bottom: none; }
        .stats-level { color: #666; }
        .stats-count { font-weight: 600; color: #2563eb; }
        .stats-toggle-btn { position: absolute; top: 8px; right: 8px; width: 26px; height: 26px; border: 1px solid #e5e7eb; background: #fff; border-radius: 6px; cursor: pointer; font-weight: 600; font-size: 16px; line-height: 1; color: #1f2937; display: flex; align-items: center; justify-content: center; box-shadow: 0 1px 2px rgba(0,0,0,0.05); }
        .stats-toggle-btn:hover { background: #f3f4f6; }
        .stats-panel.collapsed .stats-toggle-btn { color: #2563eb; }
        .btn { padding: 6px 10px; border: 1px solid #ddd; background: #fff; border-radius: 6px; cursor: pointer; color: #1f2937; font-weight: 500; }
        .btn:hover { background: #f3f4f6; }
        .viewport { position: relative; width: 100vw; height: 100vh; overflow: hidden; background: #fafafa; }
        .canvas { position: absolute; top: 0; left: 0; width: 6500px; height: 8450px; transform-origin: 0 0; }
        .grid { position: absolute; inset: 0; background-image: linear-gradient(#eee 1px, transparent 1px), linear-gradient(90deg, #eee 1px, transparent 1px); background-size: 40px 40px, 40px 40px; pointer-events: none; }
        .grid.heavy { background-image: linear-gradient(#eee 1px, transparent 1px), linear-gradient(90deg, #eee 1px, transparent 1px), linear-gradient(#e2e8f0 1px, transparent 1px), linear-gradient(90deg, #e2e8f0 1px, transparent 1px); background-size: 40px 40px, 40px 40px, 200px 200px, 200px 200px; }
        .links { position: absolute; inset: 0; pointer-events: none; }
        .link-path { fill: none; stroke: #2563eb; stroke-width: 4; opacity: 0.9; }
        .link-shadow { fill: none; stroke: rgba(37,99,235,0.25); stroke-width: 8; }
        .card { position: absolute; min-width: 140px; min-height: 64px; padding: 10px 12px; background: white; border: 2px solid #cbd5e1; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.06); cursor: grab; user-select: none; transition: box-shadow 0.15s ease; color: #1f2937; }
        .card:hover { box-shadow: 0 6px 18px rgba(0,0,0,0.1); }
        .card.dragging { cursor: grabbing; z-index: 2000; }
        .card .badge { 
            position: absolute; 
            bottom: -10px; 
            left: -10px; 
            background: #1f2937; 
            color: #fff; 
            font-size: 12px; 
            font-weight: 600;
            padding: 4px 8px; 
            border-radius: 8px; 
            box-shadow: 0 2px 6px rgba(0,0,0,0.15);
            z-index: 20;
            min-width: 24px;
            text-align: center;
        }
        .card .badge.level-up {
            background: #22c55e;
            animation: pulse 2s infinite;
        }
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        .card .progress-indicator {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: #e5e7eb;
            border-radius: 0 0 8px 8px;
        }
        .card .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #ef4444, #f59e0b, #22c55e);
            border-radius: 0 0 8px 8px;
            transition: width 0.3s ease;
        }
        .card .financial-summary {
            margin-top: 6px;
            display: flex;
            gap: 10px;
            font-size: 12px;
            color: #1f2937;
        }
        .card .financial-summary span {
            display: inline-flex;
            align-items: center;
            gap: 4px;
        }
        .card .name { font-weight: 600; color: #1f2937; }
        .card .uid { font-size: 12px; opacity: 0.6; color: #4b5563; }
        .card .delete-btn { position: absolute; top: -8px; right: -8px; width: 20px; height: 20px; background: #ef4444; color: white; border: none; border-radius: 50%; cursor: pointer; font-size: 12px; display: flex; align-items: center; justify-content: center; opacity: 0; transition: opacity 0.2s; z-index: 10; line-height: 1; }
        .card:hover .delete-btn { opacity: 1; }
        .card .delete-btn:hover { background: #dc2626; }
        .card .fill-btn { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); padding: 8px 16px; background: #3b82f6; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 12px; font-weight: 600; z-index: 10; display: none; }
        .card.empty .fill-btn { display: block; }
        .card.empty .name, .card.empty .uid { display: none; }
        .card.empty { border-style: dashed; opacity: 0.7; }
        .card .fill-children-btn { position: absolute; bottom: 8px; left: 50%; transform: translateX(-50%); padding: 6px 12px; background: #10b981; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 11px; font-weight: 600; z-index: 10; white-space: nowrap; }
        .card .fill-children-btn:hover { background: #059669; }
        .card .fill-children-btn:disabled { opacity: 0.6; cursor: not-allowed; }
        .card .add-child-btn { position: absolute; top: -8px; left: -8px; width: 24px; height: 24px; background: #10b981; color: white; border: none; border-radius: 50%; cursor: pointer; font-size: 16px; font-weight: 600; z-index: 10; display: flex; align-items: center; justify-content: center; box-shadow: 0 2px 6px rgba(0,0,0,0.15); opacity: 0; transition: opacity 0.2s; line-height: 1; }
        .card:hover .add-child-btn { opacity: 1; }
        .card .add-child-btn:hover { background: #059669; }
        .card .add-child-btn:disabled { opacity: 0.3; cursor: not-allowed; background: #9ca3af; }
        .point { position: absolute; width: 12px; height: 12px; border-radius: 50%; background: #22c55e; border: 2px solid #16a34a; top: 50%; transform: translateY(-50%); cursor: pointer; }
        .point.left { left: -8px; }
        .point.right { right: -8px; }
        .point.disabled { background: #e5e7eb; border-color: #cbd5e1; cursor: not-allowed; }
        .guide-line,
        .guide-line-vertical { display: none; }
    </style>
</head>
<body>
    <div class="toolbar">
        <button class="btn" id="menuToggle" style="background: #6366f1; color: white; font-weight: 600;">‚ò∞ –ú–µ–Ω—é</button>
        <div class="zoom-controls">
            <button class="btn zoom-btn" id="quickZoomOut" title="–£–º–µ–Ω—å—à–∏—Ç—å –º–∞—Å—à—Ç–∞–±">‚àí</button>
            <button class="btn zoom-btn" id="quickZoomIn" title="–£–≤–µ–ª–∏—á–∏—Ç—å –º–∞—Å—à—Ç–∞–±">+</button>
            <button class="btn zoom-btn" id="quickZoomFit" title="–ü–æ–∫–∞–∑–∞—Ç—å –≤—Å—é –∫–∞—Ä—Ç—É">‚§¢</button>
        </div>
        <button class="btn" id="refreshData" style="background: #14b8a6; color: white;">‚ü≥ –û–±–Ω–æ–≤–∏—Ç—å –¥–∞–Ω–Ω—ã–µ</button>
        <div class="menu-dropdown" id="menuDropdown">
            <div class="menu-section">
                <div class="menu-title">–ù–∞–≤–∏–≥–∞—Ü–∏—è</div>
                <button class="btn menu-btn" id="toggleGrid">–°–∫—Ä—ã—Ç—å —Å–µ—Ç–∫—É</button>
                <button class="btn menu-btn" id="center">–¶–µ–Ω—Ç—Ä–∏—Ä–æ–≤–∞—Ç—å</button>
                <button class="btn menu-btn" id="showAll" style="background: #3b82f6; color: white;">üîç –ü–æ–∫–∞–∑–∞—Ç—å –≤—Å–µ</button>
                <button class="btn menu-btn" id="showFullGrid" style="background: #f59e0b; color: white;">üìê –í—Å—è —Å–µ—Ç–∫–∞</button>
            </div>
            <div class="menu-section">
                <div class="menu-title">–ú–∞—Å—à—Ç–∞–±</div>
                <button class="btn menu-btn" id="snap">–ü—Ä–∏–≤—è–∑–∫–∞ –∫ —Å–µ—Ç–∫–µ: –í–∫–ª</button>
                <button class="btn menu-btn" id="zoomOut">‚àí –£–º–µ–Ω—å—à–∏—Ç—å</button>
                <button class="btn menu-btn" id="zoomIn">+ –£–≤–µ–ª–∏—á–∏—Ç—å</button>
            </div>
            <div class="menu-section">
                <div class="menu-title">–†–∞—Å–ø–æ–ª–æ–∂–µ–Ω–∏–µ</div>
                <button class="btn menu-btn" id="autoLayout" style="background: #6366f1; color: white;">üìê –†–∞—Å—Å—Ç–∞–≤–∏—Ç—å</button>
            </div>
            <div class="menu-section">
                <div class="menu-title">–ò–º–ø–æ—Ä—Ç/–≠–∫—Å–ø–æ—Ä—Ç</div>
                <button class="btn menu-btn" id="importCoords" style="background: #06b6d4; color: white;">üì§ –ò–º–ø–æ—Ä—Ç –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç</button>
                <button class="btn menu-btn" id="exportCoords" style="background: #8b5cf6; color: white;">üì• –≠–∫—Å–ø–æ—Ä—Ç –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç</button>
            </div>
            <div class="menu-section">
                <div class="menu-title">–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã–º–∏</div>
                <button class="btn menu-btn" id="clearTestData" style="background: #f59e0b; color: white;">üßπ –û—á–∏—Å—Ç–∏—Ç—å —Ç–µ—Å—Ç–æ–≤—ã–µ –¥–∞–Ω–Ω—ã–µ</button>
                <button class="btn menu-btn" id="clearAll" style="background: #ef4444; color: white;">üóëÔ∏è –û—á–∏—Å—Ç–∏—Ç—å –≤—Å–µ—Ö</button>
                <button class="btn menu-btn" id="saveLayout" style="background: #10b981; color: white;">üíæ –°–æ—Ö—Ä–∞–Ω–∏—Ç—å</button>
            </div>
        </div>
    </div>
    <div class="stats-panel" id="statsPanel">
        <button class="stats-toggle-btn" id="statsToggle" type="button" title="–°–≤–µ—Ä–Ω—É—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É" aria-label="–°–≤–µ—Ä–Ω—É—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É">‚àí</button>
        <div class="stats-title">üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–æ —É—Ä–æ–≤–Ω—è–º</div>
        <div id="statsContent"></div>
    </div>
    <div class="viewport" id="viewport">
        <div class="canvas" id="canvas">
            <div class="grid heavy" id="grid"></div>
            <svg class="links" id="links" width="6500" height="8450"></svg>
            <!-- –ü–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–µ–º—ã–µ –ª–∏–Ω–∏–∏-–æ—Ä–∏–µ–Ω—Ç–∏—Ä—ã -->
            <div class="guide-line" style="top: 1000px;"></div>
            <div class="guide-line" style="top: 2500px;"></div>
            <div class="guide-line" style="top: 4000px;"></div>
            <div class="guide-line" style="top: 5500px;"></div>
            <div class="guide-line" style="top: 7000px;"></div>
            <!-- –í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—ã–µ –ª–∏–Ω–∏–∏-–æ—Ä–∏–µ–Ω—Ç–∏—Ä—ã -->
            <div class="guide-line-vertical" style="left: 1000px;"></div>
            <div class="guide-line-vertical" style="left: 2000px;"></div>
            <div class="guide-line-vertical" style="left: 3000px;"></div>
            <div class="guide-line-vertical" style="left: 4000px;"></div>
            <div class="guide-line-vertical" style="left: 5000px;"></div>
            <!-- –ê–≤—Ç–æ-—Ä–∞—Å–∫–ª–∞–¥–∫–∞ –ø—Ä–∏–º–µ—Ä–∞ –ø–æ —É—Ä–æ–≤–Ω—è–º -->
            <div class="card" data-id="root" data-level="0" data-name="IVA" data-uid="0000001" style="left: 2400px; top: 200px;"></div>
        </div>
    </div>

    <script>
        const GRID_SIZE = 40;
        const DEFAULT_PLACEHOLDER_DEPTH = 2;
        const DIRECT_INVITE_BONUS = 50;
        const LEVEL_TRANSITION_REWARDS = [
            { level: 1, yellow: 150, transition: 150 },
            { level: 2, yellow: 300, transition: 300 },
            { level: 3, yellow: 600, transition: 600 },
            { level: 4, yellow: 1200, transition: 1200 },
        ];
        const LEVEL_WITHDRAWAL_REWARD = { level: 4, amount: 2500 };
        const viewport = document.getElementById('viewport');
        let isRestoringFromStorage = false;
        let serverStructureStats = null;
        
        function formatMoney(value) {
            const amount = Number(value || 0);
            return `$${amount.toLocaleString('en-US', { minimumFractionDigits: 0, maximumFractionDigits: 0 })}`;
        }
        // –†–µ–Ω–¥–µ—Ä —Å–æ–¥–µ—Ä–∂–∏–º–æ–≥–æ –∫–∞—Ä—Ç–æ—á–∫–∏ (–∏–º—è, id, –±–µ–π–¥–∂ —É—Ä–æ–≤–Ω—è)
        function renderCardContents(card) {
            const isRoot = card.dataset.id === 'root';
            const depth = parseInt(card.dataset.level || '0');
            // –í—Å–µ –∫–∞—Ä—Ç–æ—á–∫–∏ –ø–æ–∫–∞–∑—ã–≤–∞—é—Ç —Å–≤–æ–π —Ä–µ–∞–ª—å–Ω—ã–π —É—Ä–æ–≤–µ–Ω—å (–≤–∫–ª—é—á–∞—è root)
            const displayLevel = depth;
            const isEmpty = !card.dataset.name || !card.dataset.uid;
            const directInvites = parseInt(
                card.dataset.directInvites !== undefined
                    ? card.dataset.directInvites
                    : card.dataset.directReferrals || '0',
                10
            );
            const directReferrals = parseInt(card.dataset.directReferrals || '0', 10);
            const totalReferrals = parseInt(card.dataset.totalReferrals || '0', 10);
            const bonusYellow = parseFloat(card.dataset.bonusYellow || '0');
            const payoutGreen = parseFloat(card.dataset.payoutGreen || '0');
            const financialHtml = `
                <div class="financial-summary">
                    <span title="–ü—Ä–∏–≥–ª–∞—à–µ–Ω–æ">ü§ù ${directInvites}</span>
                    <span title="–í—Å–µ–≥–æ —Ä–µ—Ñ–µ—Ä–∞–ª–æ–≤">üåê ${totalReferrals}</span>
                    <span title="–ë–æ–Ω—É—Å—ã">üü° ${formatMoney(bonusYellow)}</span>
                    <span title="–ö –≤—ã–≤–æ–¥—É">üü¢ ${formatMoney(payoutGreen)}</span>
                </div>
            `;
            
            // –í—ã—á–∏—Å–ª—è–µ–º –ø—Ä–æ–≥—Ä–µ—Å—Å –¥–ª—è –ø–æ–≤—ã—à–µ–Ω–∏—è —É—Ä–æ–≤–Ω—è
            const cardId = card.dataset.id;
            const partners = Array.from(canvas.querySelectorAll(`.card[data-parent="${cardId}"]`))
                .filter(child => child.dataset.name && child.dataset.uid);
            
            // –ì—Ä—É–ø–ø–∏—Ä—É–µ–º –ø–∞—Ä—Ç–Ω–µ—Ä–æ–≤ –ø–æ —É—Ä–æ–≤–Ω—è–º
            const partnersByLevel = {};
            partners.forEach(partner => {
                const partnerLevel = parseInt(partner.dataset.level || '0');
                if (!partnersByLevel[partnerLevel]) {
                    partnersByLevel[partnerLevel] = [];
                }
                partnersByLevel[partnerLevel].push(partner);
            });
            
            // –ü–∞—Ä—Ç–Ω–µ—Ä—ã —Ç–µ–∫—É—â–µ–≥–æ —É—Ä–æ–≤–Ω—è –¥–ª—è –ø–æ–≤—ã—à–µ–Ω–∏—è
            const partnersAtCurrentLevel = partnersByLevel[depth] || [];
            const neededForNextLevel = Math.max(0, 3 - partnersAtCurrentLevel.length);
            const progressPercent = Math.min(100, (partnersAtCurrentLevel.length / 3) * 100);
            const canLevelUp = partnersAtCurrentLevel.length >= 3;
            
            // –ï—Å–ª–∏ –∫–∞—Ä—Ç–æ—á–∫–∞ –ø—É—Å—Ç–∞—è, –¥–æ–±–∞–≤–ª—è–µ–º –∫–ª–∞—Å—Å empty
            if (isEmpty && !isRoot) {
                card.classList.add('empty');
            } else {
                card.classList.remove('empty');
            }
            
            // –î–æ–±–∞–≤–ª—è–µ–º –∫–ª–∞—Å—Å –¥–ª—è –∞–Ω–∏–º–∞—Ü–∏–∏ –ø–æ–≤—ã—à–µ–Ω–∏—è —É—Ä–æ–≤–Ω—è
            if (canLevelUp) {
                card.classList.add('can-level-up');
            } else {
                card.classList.remove('can-level-up');
            }
            
            if (isEmpty && !isRoot) {
                // –ü—É—Å—Ç–∞—è –∫–∞—Ä—Ç–æ—á–∫–∞ - –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –∫–Ω–æ–ø–∫—É –∑–∞–ø–æ–ª–Ω–µ–Ω–∏—è –∏ –∫–Ω–æ–ø–∫—É "+"
                card.innerHTML = `
                    <div class="badge ${canLevelUp ? 'level-up' : ''}">${displayLevel}</div>
                    <button class="fill-btn" title="–ó–∞–ø–æ–ª–Ω–∏—Ç—å –∫–∞—Ä—Ç–æ—á–∫—É –∏ –µ—ë –¥–æ—á–µ—Ä–Ω–∏–µ –æ–±—ä–µ–∫—Ç—ã">–ó–∞–ø–æ–ª–Ω–∏—Ç—å</button>
                    <button class="add-child-btn" title="–î–æ–±–∞–≤–∏—Ç—å –¥–æ—á–µ—Ä–Ω–∏–π –æ–±—ä–µ–∫—Ç">+</button>
                    <button class="delete-btn" title="–£–¥–∞–ª–∏—Ç—å –∫–∞—Ä—Ç–æ—á–∫—É –∏ –≤—Å–µ—Ö –µ—ë –¥–µ—Ç–µ–π">√ó</button>
                    ${financialHtml}
                    ${!isEmpty ? `<div class="progress-indicator"><div class="progress-bar" style="width: ${progressPercent}%"></div></div>` : ''}
                `;
                // –î–æ–±–∞–≤–ª—è–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –∑–∞–ø–æ–ª–Ω–µ–Ω–∏—è
                const fillBtn = card.querySelector('.fill-btn');
                if (fillBtn) {
                    fillBtn.addEventListener('click', async (e) => {
                        e.stopPropagation();
                        fillBtn.disabled = true;
                        fillBtn.textContent = '–ó–∞–ø–æ–ª–Ω—è–µ—Ç—Å—è...';
                        await fillCard(card);
                        fillBtn.disabled = false;
                    });
                }
                // –î–æ–±–∞–≤–ª—è–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –¥–ª—è –∫–Ω–æ–ø–∫–∏ "+"
                const addChildBtn = card.querySelector('.add-child-btn');
                if (addChildBtn) {
                    addChildBtn.addEventListener('click', async (e) => {
                        e.stopPropagation();
                        await fillNextChild(card);
                    });
                }
            } else {
                // –ó–∞–ø–æ–ª–Ω–µ–Ω–Ω–∞—è –∫–∞—Ä—Ç–æ—á–∫–∞ - –¥–æ–±–∞–≤–ª—è–µ–º –∫–Ω–æ–ø–∫—É "+" –¥–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –¥–æ—á–µ—Ä–Ω–∏—Ö –æ–±—ä–µ–∫—Ç–æ–≤
                card.innerHTML = `
                    <div class="badge ${canLevelUp ? 'level-up' : ''}" title="–£—Ä–æ–≤–µ–Ω—å ${displayLevel}. –î–ª—è –ø–æ–≤—ã—à–µ–Ω–∏—è –Ω—É–∂–Ω–æ ${neededForNextLevel > 0 ? `–µ—â–µ ${neededForNextLevel} –ø–∞—Ä—Ç–Ω–µ—Ä${neededForNextLevel === 1 ? '–∞' : '–æ–≤'}` : '–≥–æ—Ç–æ–≤ –∫ –ø–æ–≤—ã—à–µ–Ω–∏—é'}">${displayLevel}</div>
                    ${!isRoot ? '<button class="delete-btn" title="–£–¥–∞–ª–∏—Ç—å –∫–∞—Ä—Ç–æ—á–∫—É –∏ –≤—Å–µ—Ö –µ—ë –¥–µ—Ç–µ–π">√ó</button>' : ''}
                    <button class="add-child-btn" title="–î–æ–±–∞–≤–∏—Ç—å –¥–æ—á–µ—Ä–Ω–∏–π –æ–±—ä–µ–∫—Ç">+</button>
                    <div class="name">${card.dataset.name}</div>
                    <div class="uid">ID${card.dataset.uid}</div>
                    ${financialHtml}
                    ${partners.length > 0 ? `<div class="progress-indicator"><div class="progress-bar" style="width: ${progressPercent}%"></div></div>` : ''}
                `;
                
                // –î–æ–±–∞–≤–ª—è–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –¥–ª—è –∫–Ω–æ–ø–∫–∏ "+"
                const addChildBtn = card.querySelector('.add-child-btn');
                if (addChildBtn) {
                    addChildBtn.addEventListener('click', async (e) => {
                        e.stopPropagation();
                        await fillNextChild(card);
                    });
                }
            }
            
            // –î–æ–±–∞–≤–ª—è–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ —É–¥–∞–ª–µ–Ω–∏—è
            if (!isRoot) {
                const deleteBtn = card.querySelector('.delete-btn');
                if (deleteBtn) {
                    deleteBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        deleteCardAndChildren(card);
                    });
                }
            }
        }
        
        // –ó–∞–ø–æ–ª–Ω–µ–Ω–∏–µ –∫–∞—Ä—Ç–æ—á–∫–∏ –¥–∞–Ω–Ω—ã–º–∏
        function chooseSideForNewChild(parentCard, existingChildren) {
            if (existingChildren.length === 0) return 'middle';
            if (existingChildren.length === 1) {
                const existing = existingChildren[0];
                const parentX = parseInt(parentCard.style.left) || 0;
                const childX = parseInt(existing.style.left) || 0;
                if (childX < parentX) return 'right';
                if (childX > parentX) return 'left';
                return 'left';
            }
            const parentX = parseInt(parentCard.style.left) || 0;
            let leftCount = 0;
            let rightCount = 0;
            existingChildren.forEach(child => {
                const childX = parseInt(child.style.left) || 0;
                if (childX < parentX) {
                    leftCount += 1;
                } else {
                    rightCount += 1;
                }
            });
            return leftCount <= rightCount ? 'left' : 'right';
        }
        
        // –ó–∞–ø–æ–ª–Ω–µ–Ω–∏–µ –æ–¥–Ω–æ–≥–æ –¥–æ—á–µ—Ä–Ω–µ–≥–æ –æ–±—ä–µ–∫—Ç–∞ (–∏–ª–∏ –¥–æ—á–µ—Ä–Ω–µ–≥–æ –¥–æ—á–µ—Ä–Ω–µ–≥–æ –µ—Å–ª–∏ –≤—Å–µ 3 –∑–∞–Ω—è—Ç—ã)
        async function fillNextChild(card) {
            async function internalFill(targetCard) {
                const cardId = targetCard.dataset.id;
                let children = Array.from(canvas.querySelectorAll(`.card[data-parent="${cardId}"]`));

                if (children.length < 3) {
                    const side = chooseSideForNewChild(targetCard, children);
                    const newChild = createChild(targetCard, side);
                    if (newChild) {
                        children = Array.from(canvas.querySelectorAll(`.card[data-parent="${cardId}"]`));
                    }
                }

                const emptyChildren = children
                    .filter(child => !child.dataset.name || !child.dataset.uid)
                    .sort((a, b) => {
                        const topA = parseInt(a.style.top) || 0;
                        const topB = parseInt(b.style.top) || 0;
                        return topA - topB;
                    });

                if (emptyChildren.length > 0) {
                    const child = emptyChildren[0];
                    if (!child.dataset.name) child.dataset.name = generateRandomName();
                    if (!child.dataset.uid) child.dataset.uid = generateRandomId();
                    child.dataset.level = '0';
                    await saveCardToDatabase(child);
                    return targetCard;
                }

                if (children.length === 0) {
                    return null;
                }

                const candidates = children
                    .map(child => ({
                        element: child,
                        filled: countFilledChildren(child),
                        top: parseInt(child.style.top) || 0,
                        left: parseInt(child.style.left) || 0,
                    }))
                    .sort((a, b) => {
                        if (a.filled !== b.filled) return a.filled - b.filled;
                        if (a.top !== b.top) return a.top - b.top;
                        if (a.left !== b.left) return a.left - b.left;
                        return (a.element.dataset.id || '').localeCompare(b.element.dataset.id || '');
                    });

                for (const candidate of candidates) {
                    const addedFor = await internalFill(candidate.element);
                    if (addedFor) {
                        return addedFor;
                    }
                }
                return null;
            }

            const updatedParent = await internalFill(card);
            if (updatedParent) {
                incrementDirectInvites(card);
                await recalculateAllLevels();
                renderCardContents(updatedParent);
                renderCardContents(card);
                savePositions();
                updateStats();
            }
        }
        
        function getCardLevel(card) {
            return parseInt(card.dataset.level || '0', 10) || 0;
        }

        function isCardFilled(card) {
            return Boolean(card.dataset && card.dataset.name && card.dataset.uid);
        }

        function buildStructureState() {
            const nodes = new Map();
            canvas.querySelectorAll('.card').forEach(card => {
                const id = card.dataset.id;
                if (!id) return;
                card.dataset.directReferrals = card.dataset.directReferrals || '0';
                card.dataset.totalReferrals = card.dataset.totalReferrals || '0';
                card.dataset.bonusYellow = card.dataset.bonusYellow || '0';
                card.dataset.transitionRed = card.dataset.transitionRed || '0';
                card.dataset.payoutGreen = card.dataset.payoutGreen || '0';
                card.dataset.directInvites = card.dataset.directInvites || card.dataset.directReferrals || '0';
                const node = {
                    id,
                    element: card,
                    parentId: card.dataset.parent || null,
                    level: getCardLevel(card),
                    newLevel: getCardLevel(card),
                    children: [],
                    filled: isCardFilled(card),
                    depth: 0,
                    directInvites: parseInt(card.dataset.directInvites || card.dataset.directReferrals || '0', 10),
                };
                nodes.set(id, node);
            });

            nodes.forEach(node => {
                if (node.parentId && nodes.has(node.parentId)) {
                    nodes.get(node.parentId).children.push(node.id);
                }
            });

            const root = nodes.get('root');
            if (root) {
                const queue = [root];
                const visited = new Set(['root']);
                root.depth = 0;
                while (queue.length > 0) {
                    const current = queue.shift();
                    current.children.forEach(childId => {
                        const child = nodes.get(childId);
                        if (!child || visited.has(childId)) return;
                        child.depth = current.depth + 1;
                        visited.add(childId);
                        queue.push(child);
                    });
                }
            }

            const ordered = Array.from(nodes.values()).sort((a, b) => b.depth - a.depth);

            return { nodes, root, ordered };
        }

        function calculateLevelFromChildren(node, nodes) {
            const childNodes = node.children
                .map(childId => nodes.get(childId))
                .filter(child => child && child.filled);

            let level = 0;
            while (childNodes.filter(child => child.newLevel >= level).length >= 3) {
                level += 1;
            }
            return level;
        }

        function calculateFinancialSummary(node) {
            const personalInvites = node.directInvites || 0;
            const directFilled = node.directFilled || 0;
            const completedLevel = node.level || 0;

            let yellow = personalInvites * DIRECT_INVITE_BONUS;
            let red = Math.min(directFilled, 3) * DIRECT_INVITE_BONUS;
            let green = personalInvites * DIRECT_INVITE_BONUS;

            if (LEVEL_WITHDRAWAL_REWARD && completedLevel >= LEVEL_WITHDRAWAL_REWARD.level) {
                green += LEVEL_WITHDRAWAL_REWARD.amount;
            }

            return { yellow, red, green };
        }

        function recalculateAllLevels(options = {}) {
            const {
                preserveRootLevel = false,
                forceRootLevel = null,
                skipSave = false,
            } = options;
            const { nodes, root, ordered } = buildStructureState();
            if (!root) return false;

            ordered.forEach(node => {
                if (node.id === 'root' && preserveRootLevel) {
                    node.newLevel = node.level;
                } else {
                    node.newLevel = calculateLevelFromChildren(node, nodes);
                }
            });

            if (root && forceRootLevel !== null) {
                root.newLevel = forceRootLevel;
            }

            let changed = false;
            const changedNodes = [];
            ordered.forEach(node => {
                if (node.level !== node.newLevel) {
                    node.element.dataset.level = String(node.newLevel);
                    node.level = node.newLevel;
                    changed = true;
                    changedNodes.push(node);
                }
            });

            if (changed && !skipSave && !isRestoringFromStorage) {
                changedNodes.forEach(node => {
                    if (node.filled) {
                        saveCardToDatabase(node.element);
                    }
                });
            }

            ordered.forEach(node => {
            const childNodes = node.children
                .map(childId => nodes.get(childId))
                .filter(Boolean);

            const directFilled = childNodes.filter(child => child && child.filled).length;
            node.directFilled = directFilled;
            node.directInvites = parseInt(node.element.dataset.directInvites || '0', 10);
            node.activeDescendants = childNodes.reduce((sum, child) => {
                    return sum + (child.activeDescendantsIncludingSelf || 0);
                }, 0);
                node.activeDescendantsIncludingSelf = node.activeDescendants + (node.filled ? 1 : 0);

                const financial = calculateFinancialSummary(node);
                node.element.dataset.directReferrals = String(node.directFilled);
                node.element.dataset.directInvites = String(node.directInvites);
                node.element.dataset.totalReferrals = String(node.activeDescendants);
                node.element.dataset.bonusYellow = financial.yellow.toFixed(2);
                node.element.dataset.transitionRed = financial.red.toFixed(2);
                node.element.dataset.payoutGreen = financial.green.toFixed(2);
                renderCardContents(node.element);
            });
            return changed;
        }
        
        // –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –∫–∞—Ä—Ç–æ—á–∫–∏ –≤ –±–∞–∑—É –¥–∞–Ω–Ω—ã—Ö
        async function saveCardToDatabase(card) {
            try {
                const parentId = card.dataset.parent;
                const parentCard = parentId ? canvas.querySelector(`.card[data-id="${parentId}"]`) : null;
                const inviterId = parentCard ? parentCard.dataset.uid : null;
                
                const cardData = {
                    uid: card.dataset.uid,
                    name: card.dataset.name,
                    level: parseInt(card.dataset.level || '0'),
                    display_level: parseInt(card.dataset.level || '0'),
                    inviter_uid: inviterId,
                    left: parseInt(card.style.left) || 0,
                    top: parseInt(card.style.top) || 0
                };
                
                const response = await fetch('/admin-panel/api/save-card/', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': getCookie('csrftoken')
                    },
                    body: JSON.stringify(cardData)
                });
                
                if (!response.ok) {
                    console.error('–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –∫–∞—Ä—Ç–æ—á–∫–∏:', await response.text());
                }
            } catch (error) {
                console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏ –∫–∞—Ä—Ç–æ—á–∫–∏ –≤ –±–∞–∑—É:', error);
            }
        }
        
        // –ü–æ–ª—É—á–µ–Ω–∏–µ CSRF —Ç–æ–∫–µ–Ω–∞ –∏–∑ cookies
        function getCookie(name) {
            let cookieValue = null;
            if (document.cookie && document.cookie !== '') {
                const cookies = document.cookie.split(';');
                for (let i = 0; i < cookies.length; i++) {
                    const cookie = cookies[i].trim();
                    if (cookie.substring(0, name.length + 1) === (name + '=')) {
                        cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                        break;
                    }
                }
            }
            return cookieValue;
        }
        function generateRandomId() { return String(Math.floor(1000000 + Math.random()*9000000)); }
        function generateRandomName() {
            const first = ['Alex','Ivan','Olga','Anna','Max','Nina','Oleg','Ilya','Vera','Mira','Dima','Pavel'];
            const last = ['Petrov','Sidorov','Morozov','Kuznetsov','Smirnov','Volkov','Lebedev','Antonov'];
            return first[Math.floor(Math.random()*first.length)] + ' ' + last[Math.floor(Math.random()*last.length)];
        }
        const canvas = document.getElementById('canvas');
        const grid = document.getElementById('grid');
        const links = document.getElementById('links');
        
        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–µ–º—ã—Ö –ª–∏–Ω–∏–π-–æ—Ä–∏–µ–Ω—Ç–∏—Ä–æ–≤
        let guideLineDragging = null;
        function initGuideLines() {
            // –ì–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—ã–µ –ª–∏–Ω–∏–∏
            const guideLines = canvas.querySelectorAll('.guide-line');
            guideLines.forEach(line => {
                line.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    guideLineDragging = line;
                    const { y } = toCanvasCoords(e.clientX, e.clientY);
                    const lineTop = parseInt(line.style.top) || 0;
                    guideLineDragging.dataset.dragOffset = y - lineTop;
                    guideLineDragging.dataset.dragType = 'horizontal';
                    line.style.opacity = '1';
                });
            });
            
            // –í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—ã–µ –ª–∏–Ω–∏–∏
            const guideLinesVertical = canvas.querySelectorAll('.guide-line-vertical');
            guideLinesVertical.forEach(line => {
                line.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    guideLineDragging = line;
                    const { x } = toCanvasCoords(e.clientX, e.clientY);
                    const lineLeft = parseInt(line.style.left) || 0;
                    guideLineDragging.dataset.dragOffset = x - lineLeft;
                    guideLineDragging.dataset.dragType = 'vertical';
                    line.style.opacity = '1';
                });
            });
        }
        
        // –û–±—Ä–∞–±–æ—Ç–∫–∞ –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏—è –ª–∏–Ω–∏–π
        window.addEventListener('mousemove', (e) => {
            if (!guideLineDragging) return;
            const dragType = guideLineDragging.dataset.dragType;
            
            if (dragType === 'horizontal') {
                const { y } = toCanvasCoords(e.clientX, e.clientY);
                const dragOffset = parseFloat(guideLineDragging.dataset.dragOffset || 0);
                const newTop = y - dragOffset;
                // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –≤ –ø—Ä–µ–¥–µ–ª–∞—Ö canvas
                const clampedTop = Math.max(0, Math.min(8450, newTop));
                guideLineDragging.style.top = Math.round(clampedTop / GRID_SIZE) * GRID_SIZE + 'px';
            } else if (dragType === 'vertical') {
                const { x } = toCanvasCoords(e.clientX, e.clientY);
                const dragOffset = parseFloat(guideLineDragging.dataset.dragOffset || 0);
                const newLeft = x - dragOffset;
                // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –≤ –ø—Ä–µ–¥–µ–ª–∞—Ö canvas
                const clampedLeft = Math.max(0, Math.min(6500, newLeft));
                guideLineDragging.style.left = Math.round(clampedLeft / GRID_SIZE) * GRID_SIZE + 'px';
            }
        });
        
        window.addEventListener('mouseup', () => {
            if (guideLineDragging) {
                guideLineDragging.style.opacity = '0.7';
                guideLineDragging = null;
            }
        });
        const btnGrid = document.getElementById('toggleGrid');
        const btnCenter = document.getElementById('center');
        const btnSnap = document.getElementById('snap');
        const btnZoomIn = document.getElementById('zoomIn');
        const btnZoomOut = document.getElementById('zoomOut');
        const btnQuickZoomIn = document.getElementById('quickZoomIn');
        const btnQuickZoomOut = document.getElementById('quickZoomOut');
        const btnQuickZoomFit = document.getElementById('quickZoomFit');
        const btnRefreshData = document.getElementById('refreshData');
        const btnShowAll = document.getElementById('showAll');
        const btnShowFullGrid = document.getElementById('showFullGrid');
        const btnAutoLayout = document.getElementById('autoLayout');
        const btnImportCoords = document.getElementById('importCoords');
        const btnExportCoords = document.getElementById('exportCoords');
        const btnClearTestData = document.getElementById('clearTestData');
        const btnClearAll = document.getElementById('clearAll');
        const btnSaveLayout = document.getElementById('saveLayout');
        const btnMenuToggle = document.getElementById('menuToggle');
        const menuDropdown = document.getElementById('menuDropdown');
        const statsContent = document.getElementById('statsContent');
        const statsPanel = document.getElementById('statsPanel');
        const statsToggle = document.getElementById('statsToggle');
        
        // –ü–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ –º–µ–Ω—é
        btnMenuToggle.addEventListener('click', (e) => {
            e.stopPropagation();
            menuDropdown.classList.toggle('show');
        });
        
        // –ó–∞–∫—Ä—ã—Ç–∏–µ –º–µ–Ω—é –ø—Ä–∏ –∫–ª–∏–∫–µ –≤–Ω–µ –µ–≥–æ
        document.addEventListener('click', (e) => {
            if (!menuDropdown.contains(e.target) && e.target !== btnMenuToggle) {
                menuDropdown.classList.remove('show');
            }
        });

        const STATS_COLLAPSE_KEY = 'structure_v2_stats_collapsed';
        let statsCollapsed = false;
        function applyStatsCollapsed(collapsed) {
            statsCollapsed = collapsed;
            if (statsPanel) {
                statsPanel.classList.toggle('collapsed', collapsed);
            }
            if (statsToggle) {
                const title = collapsed ? '–†–∞–∑–≤–µ—Ä–Ω—É—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É' : '–°–≤–µ—Ä–Ω—É—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É';
                statsToggle.textContent = collapsed ? '+' : '‚àí';
                statsToggle.setAttribute('aria-expanded', collapsed ? 'false' : 'true');
                statsToggle.setAttribute('title', title);
                statsToggle.setAttribute('aria-label', title);
            }
        }
        if (statsPanel && statsToggle) {
            const savedStatsState = localStorage.getItem(STATS_COLLAPSE_KEY);
            applyStatsCollapsed(savedStatsState === 'true');
            statsToggle.addEventListener('click', () => {
                applyStatsCollapsed(!statsCollapsed);
                localStorage.setItem(STATS_COLLAPSE_KEY, statsCollapsed ? 'true' : 'false');
            });
        }

        const MIN_SCALE = 0.05;
        const MAX_SCALE = 2;
        let scale = 1;
        let offsetX = 0; // –ø–∞–Ω–æ—Ä–∞–º–∞
        let offsetY = 0;
        let isPanning = false;
        let panStartX = 0, panStartY = 0;
        let canvasStartX = 0, canvasStartY = 0;
        let snapEnabled = true;

        function clampOffsets() {
            const canvasW = 6500 * scale;
            const canvasH = 8450 * scale;
            const minX = Math.min(0, viewport.clientWidth - canvasW);
            const minY = Math.min(0, viewport.clientHeight - canvasH);
            const maxX = 0;
            const maxY = 0;
            offsetX = Math.max(minX, Math.min(maxX, offsetX));
            offsetY = Math.max(minY, Math.min(maxY, offsetY));
        }
        function updateZoomButtons() {
            const canZoomIn = scale < MAX_SCALE - 0.001;
            const canZoomOut = scale > MIN_SCALE + 0.001;
            if (btnZoomIn) btnZoomIn.disabled = !canZoomIn;
            if (btnQuickZoomIn) btnQuickZoomIn.disabled = !canZoomIn;
            if (btnZoomOut) btnZoomOut.disabled = !canZoomOut;
            if (btnQuickZoomOut) btnQuickZoomOut.disabled = !canZoomOut;
        }
        function applyTransform() {
            clampOffsets();
            canvas.style.transform = `translate(${offsetX}px, ${offsetY}px) scale(${scale})`;
            updateZoomButtons();
        }

        // –ü–∞–Ω–æ—Ä–∞–º–∏—Ä–æ–≤–∞–Ω–∏–µ –ø–æ –ø—É—Å—Ç–æ–º—É –º–µ—Å—Ç—É
        viewport.addEventListener('mousedown', (e) => {
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –∫–ª–∏–∫ –Ω–µ –Ω–∞ –∫–∞—Ä—Ç–æ—á–∫–µ –∏–ª–∏ –µ—ë –¥–æ—á–µ—Ä–Ω–∏—Ö —ç–ª–µ–º–µ–Ω—Ç–∞—Ö
            if (e.target.closest('.card')) return;
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –Ω–µ –∏–¥–µ—Ç drag –∫–∞—Ä—Ç–æ—á–∫–∏
            if (dragging) return;
            isPanning = true;
            panStartX = e.clientX;
            panStartY = e.clientY;
            canvasStartX = offsetX;
            canvasStartY = offsetY;
        });
        window.addEventListener('mousemove', (e) => {
            // –ï—Å–ª–∏ –∏–¥–µ—Ç drag –∫–∞—Ä—Ç–æ—á–∫–∏, –Ω–µ –ø–∞–Ω–æ—Ä–∞–º–∏—Ä—É–µ–º
            if (dragging) {
                isPanning = false;
                return;
            }
            if (!isPanning) return;
            offsetX = canvasStartX + (e.clientX - panStartX);
            offsetY = canvasStartY + (e.clientY - panStartY);
            applyTransform();
        });
        window.addEventListener('mouseup', () => { 
            isPanning = false;
        });

        // –ó—É–º –∫–æ–ª—ë—Å–∏–∫–æ–º
        viewport.addEventListener('wheel', (e) => {
            e.preventDefault();
            const delta = e.deltaY < 0 ? 1.1 : 0.9;
            const prevScale = scale;
            scale = Math.min(MAX_SCALE, Math.max(MIN_SCALE, scale * delta));
            // –ú–∞—Å—à—Ç–∞–± –≤–æ–∫—Ä—É–≥ –∫—É—Ä—Å–æ—Ä–∞
            const rect = viewport.getBoundingClientRect();
            const cx = e.clientX - rect.left;
            const cy = e.clientY - rect.top;
            offsetX = cx - (cx - offsetX) * (scale / prevScale);
            offsetY = cy - (cy - offsetY) * (scale / prevScale);
            applyTransform();
        }, { passive: false });

        function handleZoomIn() {
            scale = Math.min(MAX_SCALE, scale * 1.1);
            applyTransform();
        }
        function handleZoomOut() {
            scale = Math.max(MIN_SCALE, scale * 0.9);
            applyTransform();
        }
        
        btnZoomIn.onclick = handleZoomIn;
        btnZoomOut.onclick = handleZoomOut;
        if (btnQuickZoomIn) btnQuickZoomIn.onclick = handleZoomIn;
        if (btnQuickZoomOut) btnQuickZoomOut.onclick = handleZoomOut;
        if (btnQuickZoomFit) btnQuickZoomFit.onclick = () => {
            showAllCards();
        };
        updateZoomButtons();
        btnCenter.onclick = () => {
            // –¶–µ–Ω—Ç—Ä–∏—Ä—É–µ–º –ø–æ–ª–æ—Ç–Ω–æ –ø–æ –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª–∏ –∏ –≤–µ—Ä—Ç–∏–∫–∞–ª–∏ –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ –≤–∏–¥–∏–º–æ–π –æ–±–ª–∞—Å—Ç–∏
            offsetX = (viewport.clientWidth - 6500 * scale) / 2;
            offsetY = (viewport.clientHeight - 8450 * scale) / 2;
            applyTransform();
        };
        btnSaveLayout.onclick = () => {
            savePositions();
            // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏
            const btn = btnSaveLayout;
            const originalText = btn.textContent;
            btn.textContent = '‚úì –°–æ—Ö—Ä–∞–Ω–µ–Ω–æ!';
            btn.style.background = '#22c55e';
            setTimeout(() => {
                btn.textContent = originalText;
                btn.style.background = '#10b981';
            }, 2000);
        };

        if (btnRefreshData) {
            btnRefreshData.addEventListener('click', async () => {
                const originalText = btnRefreshData.textContent;
                btnRefreshData.disabled = true;
                btnRefreshData.textContent = '–û–±–Ω–æ–≤–ª—è–µ–º...';
                const success = await fetchStructureFromServer({ showErrors: true });
                btnRefreshData.disabled = false;
                if (success) {
                    btnRefreshData.textContent = '‚úì –û–±–Ω–æ–≤–ª–µ–Ω–æ';
                    btnRefreshData.style.background = '#22c55e';
                } else {
                    btnRefreshData.textContent = '–û—à–∏–±–∫–∞';
                    btnRefreshData.style.background = '#ef4444';
                }
                setTimeout(() => {
                    btnRefreshData.textContent = originalText;
                    btnRefreshData.style.background = '#14b8a6';
                }, 2000);
            });
        }
        
        // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–æ–∫–∞–∑–∞ –≤—Å–µ—Ö –∫–∞—Ä—Ç–æ—á–µ–∫
        function showAllCards() {
            const cards = Array.from(canvas.querySelectorAll('.card'));
            if (cards.length === 0) return;
            
            // –ù–∞—Ö–æ–¥–∏–º –≥—Ä–∞–Ω–∏—Ü—ã –≤—Å–µ—Ö –∫–∞—Ä—Ç–æ—á–µ–∫
            let minX = Infinity, maxX = -Infinity;
            let minY = Infinity, maxY = -Infinity;
            
            cards.forEach(card => {
                const left = parseInt(card.style.left) || 0;
                const top = parseInt(card.style.top) || 0;
                const width = card.offsetWidth || 160;
                const height = card.offsetHeight || 80;
                
                minX = Math.min(minX, left);
                maxX = Math.max(maxX, left + width);
                minY = Math.min(minY, top);
                maxY = Math.max(maxY, top + height);
            });
            
            // –î–æ–±–∞–≤–ª—è–µ–º –æ—Ç—Å—Ç—É–ø—ã
            const padding = 100;
            const cardsWidth = maxX - minX + padding * 2;
            const cardsHeight = maxY - minY + padding * 2;
            const centerX = (minX + maxX) / 2;
            const centerY = (minY + maxY) / 2;
            
            // –í—ã—á–∏—Å–ª—è–µ–º –æ–ø—Ç–∏–º–∞–ª—å–Ω—ã–π –º–∞—Å—à—Ç–∞–±
            const scaleX = viewport.clientWidth / cardsWidth;
            const scaleY = viewport.clientHeight / cardsHeight;
            scale = Math.min(MAX_SCALE, Math.max(MIN_SCALE, Math.min(scaleX, scaleY) * 0.9)); // 90% —á—Ç–æ–±—ã –±—ã–ª –Ω–µ–±–æ–ª—å—à–æ–π –æ—Ç—Å—Ç—É–ø
            
            // –¶–µ–Ω—Ç—Ä–∏—Ä—É–µ–º –Ω–∞ –∫–∞—Ä—Ç–æ—á–∫–∞—Ö
            offsetX = (viewport.clientWidth - 6500 * scale) / 2 + (3250 - centerX) * scale;
            offsetY = (viewport.clientHeight - 8450 * scale) / 2 + (4225 - centerY) * scale;
            
            // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –≥—Ä–∞–Ω–∏—Ü—ã
            clampOffsets();
            applyTransform();
        }
        
        btnShowAll.onclick = () => showAllCards();
        
        // –ü–æ–∫–∞–∑–∞—Ç—å –≤—Å—é —Å–µ—Ç–∫—É (–≤–µ—Å—å canvas —Ü–µ–ª–∏–∫–æ–º)
        function showFullGrid() {
            const CANVAS_WIDTH = 6500;
            const CANVAS_HEIGHT = 8450;
            
            // –í—ã—á–∏—Å–ª—è–µ–º –º–∞—Å—à—Ç–∞–±, —á—Ç–æ–±—ã –≤–µ—Å—å canvas –ø–æ–º–µ—Å—Ç–∏–ª—Å—è –≤ viewport
            const scaleX = viewport.clientWidth / CANVAS_WIDTH;
            const scaleY = viewport.clientHeight / CANVAS_HEIGHT;
            scale = Math.min(MAX_SCALE, Math.max(MIN_SCALE, Math.min(scaleX, scaleY) * 0.95)); // 95% —á—Ç–æ–±—ã –±—ã–ª –Ω–µ–±–æ–ª—å—à–æ–π –æ—Ç—Å—Ç—É–ø
            
            // –¶–µ–Ω—Ç—Ä–∏—Ä—É–µ–º canvas
            offsetX = (viewport.clientWidth - CANVAS_WIDTH * scale) / 2;
            offsetY = (viewport.clientHeight - CANVAS_HEIGHT * scale) / 2;
            
            // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –≥—Ä–∞–Ω–∏—Ü—ã
            clampOffsets();
            applyTransform();
        }
        
        btnShowFullGrid.onclick = () => showFullGrid();
        
        // –ò–º–ø–æ—Ä—Ç –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç –∏–∑ —Ñ–∞–π–ª–∞
        function importCoordinatesFromFile() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = (e) => {
                const file = e.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const importData = JSON.parse(event.target.result);
                        
                        if (!importData.cards || !Array.isArray(importData.cards)) {
                            alert('–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç —Ñ–∞–π–ª–∞. –û–∂–∏–¥–∞–µ—Ç—Å—è –º–∞—Å—Å–∏–≤ cards.');
                            return;
                        }

                        const hydrated = hydrateStructureFromPayload(importData, {
                            autoLayoutAfter: false,
                            saveState: true,
                            resetServerStats: true,
                        });

                        if (!hydrated) {
                            alert('–ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–∏–º–µ–Ω–∏—Ç—å –¥–∞–Ω–Ω—ã–µ –∏–∑ —Ñ–∞–π–ª–∞.');
                            return;
                        }

                        const btn = btnImportCoords;
                        const originalText = btn.textContent;
                        btn.textContent = '‚úì –ò–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–æ!';
                        btn.style.background = '#22c55e';
                        setTimeout(() => {
                            btn.textContent = originalText;
                            btn.style.background = '#06b6d4';
                        }, 2000);
                        
                        setTimeout(() => showAllCards(), 300);
                        
                    } catch (error) {
                        console.error('–û—à–∏–±–∫–∞ –∏–º–ø–æ—Ä—Ç–∞:', error);
                        alert('–û—à–∏–±–∫–∞ –ø—Ä–∏ –∏–º–ø–æ—Ä—Ç–µ —Ñ–∞–π–ª–∞: ' + error.message);
                    }
                };
                reader.readAsText(file);
            };
            input.click();
        }
        
        btnImportCoords.onclick = () => importCoordinatesFromFile();

        async function fetchStructureFromServer(options = {}) {
            const { showErrors = false, autoLayout = true } = options;
            try {
                const response = await fetch(`/admin-panel/api/structure-data/?_=${Date.now()}`, {
                    headers: { 'Accept': 'application/json' }
                });
                if (!response.ok) {
                    const text = await response.text();
                    throw new Error(text || `HTTP ${response.status}`);
                }
                const payload = await response.json();
                if (payload && payload.structure && Array.isArray(payload.structure.cards)) {
                    isRestoringFromStorage = true;
                    hydrateStructureFromPayload(payload.structure, {
                        autoLayoutAfter: autoLayout,
                        saveState: true,
                        resetServerStats: false,
                        recalcLevels: true,
                    });
                    isRestoringFromStorage = false;
                    serverStructureStats = payload.stats || null;
                    updateStats();
                    setTimeout(() => showAllCards(), 200);
                    return true;
                }
                serverStructureStats = payload?.stats || null;
                updateStats();
                return false;
            } catch (error) {
                console.error('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –∏–∑ –±–∞–∑—ã', error);
                if (showErrors) {
                    alert('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã: ' + error.message);
                }
                isRestoringFromStorage = false;
                return false;
            }
        }
        
        // –≠–∫—Å–ø–æ—Ä—Ç –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç –≤—Å–µ—Ö –∫–∞—Ä—Ç–æ—á–µ–∫ –≤ —Ñ–∞–π–ª
        function exportCoordinatesToFile() {
            const cards = Array.from(canvas.querySelectorAll('.card'));
            const cardsData = cards.map(card => {
                const level = parseInt(card.dataset.level || '0');
                const displayLevel = level;
                return {
                    id: card.dataset.id,
                    name: card.dataset.name || '',
                    uid: card.dataset.uid || '',
                    level: level,
                    displayLevel: displayLevel,
                    parent: card.dataset.parent || null,
                    left: parseInt(card.style.left) || 0,
                    top: parseInt(card.style.top) || 0,
                    width: card.offsetWidth || 160,
                    height: card.offsetHeight || 80
                };
            });
            
            const exportData = {
                timestamp: new Date().toISOString(),
                canvasWidth: 6500,
                canvasHeight: 8450,
                totalCards: cardsData.length,
                uidCounter: uidCounter,
                childMap: Array.from(childMap.entries()).map(([parent, children]) => [parent, Array.from(children)]),
                cards: cardsData.sort((a, b) => {
                    // –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ —É—Ä–æ–≤–Ω—é, –∑–∞—Ç–µ–º –ø–æ –ø–æ–∑–∏—Ü–∏–∏
                    if (a.displayLevel !== b.displayLevel) return b.displayLevel - a.displayLevel;
                    if (a.top !== b.top) return a.top - b.top;
                    return a.left - b.left;
                })
            };
            
            // –°–æ–∑–¥–∞–µ–º JSON —Ñ–∞–π–ª –∏ —Å–∫–∞—á–∏–≤–∞–µ–º
            const jsonStr = JSON.stringify(exportData, null, 2);
            const blob = new Blob([jsonStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `structure_coordinates_${new Date().toISOString().split('T')[0]}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ
            const btn = btnExportCoords;
            const originalText = btn.textContent;
            btn.textContent = '‚úì –≠–∫—Å–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–æ!';
            btn.style.background = '#22c55e';
            setTimeout(() => {
                btn.textContent = originalText;
                btn.style.background = '#8b5cf6';
            }, 2000);
        }
        
        btnExportCoords.onclick = () => exportCoordinatesToFile();

        // –ü–µ—Ä–µ–∫–ª—é—á–∞—Ç–µ–ª—å —Å–µ—Ç–∫–∏
        let gridVisible = true;
        btnGrid.onclick = () => {
            gridVisible = !gridVisible;
            grid.style.display = gridVisible ? 'block' : 'none';
            btnGrid.textContent = gridVisible ? '–°–∫—Ä—ã—Ç—å —Å–µ—Ç–∫—É' : '–ü–æ–∫–∞–∑–∞—Ç—å —Å–µ—Ç–∫—É';
        };
        btnSnap.onclick = () => {
            snapEnabled = !snapEnabled;
            btnSnap.textContent = `–ü—Ä–∏–≤—è–∑–∫–∞ –∫ —Å–µ—Ç–∫–µ: ${snapEnabled ? '–í–∫–ª' : '–í—ã–∫–ª'}`;
        };

        // –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω–æ–µ: –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä id –∏ —Ä–∞–±–æ—Ç–∞ —Å –¥–µ—Ç—å–º–∏
        const childMap = new Map(); // parentId -> Set(childIds)
        let uidCounter = 1;
        function genId() { return 'node-' + (uidCounter++); }
        
        // –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ/–≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ –ø–æ–∑–∏—Ü–∏–π
        const STORAGE_KEY = 'structure_v2_positions';
        const LAYOUT_TEMPLATE_KEY = 'structure_v2_layout_template';
        
        // –°–æ—Ö—Ä–∞–Ω—è–µ–º —à–∞–±–ª–æ–Ω —Ä–∞—Å–ø–æ–ª–æ–∂–µ–Ω–∏—è –¥–µ—Ç–µ–π –¥–ª—è –∫–∞–∂–¥–æ–≥–æ —Ä–æ–¥–∏—Ç–µ–ª—è
        function saveLayoutTemplate() {
            const templates = {};
            canvas.querySelectorAll('.card').forEach(parentCard => {
                const parentId = parentCard.dataset.id;
                const children = Array.from(canvas.querySelectorAll(`.card[data-parent="${parentId}"]`));
                if (children.length === 0) return;
                
                const px = parseInt(parentCard.style.left) || 0;
                const py = parseInt(parentCard.style.top) || 0;
                
                // –°–æ—Ö—Ä–∞–Ω—è–µ–º –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω—ã–µ –ø–æ–∑–∏—Ü–∏–∏ –¥–µ—Ç–µ–π
                const childPositions = children.map(child => {
                    const cx = parseInt(child.style.left) || 0;
                    const cy = parseInt(child.style.top) || 0;
                    return {
                        offsetX: cx - px,
                        offsetY: cy - py
                    };
                });
                
                templates[parentId] = childPositions;
            });
            localStorage.setItem(LAYOUT_TEMPLATE_KEY, JSON.stringify(templates));
        }
        
        // –ó–∞–≥—Ä—É–∂–∞–µ–º —à–∞–±–ª–æ–Ω —Ä–∞—Å–ø–æ–ª–æ–∂–µ–Ω–∏—è –¥–ª—è —Ä–æ–¥–∏—Ç–µ–ª—è
        function loadLayoutTemplate(parentId) {
            const saved = localStorage.getItem(LAYOUT_TEMPLATE_KEY);
            if (!saved) return null;
            try {
                const templates = JSON.parse(saved);
                return templates[parentId] || null;
            } catch (e) {
                return null;
            }
        }
        
        function savePositions() {
            const cards = Array.from(canvas.querySelectorAll('.card'));
            const data = {
                uidCounter,
                cards: cards.map(card => ({
                    id: card.dataset.id,
                    parent: card.dataset.parent || null,
                    left: parseInt(card.style.left) || 0,
                    top: parseInt(card.style.top) || 0,
                    level: parseInt(card.dataset.level || '0'),
                    name: card.dataset.name || '',
                    uid: card.dataset.uid || '',
                    directInvites: parseInt(card.dataset.directInvites || '0', 10)
                })),
                childMap: Array.from(childMap.entries()).map(([parent, children]) => [parent, Array.from(children)])
            };
            localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
            // –°–æ—Ö—Ä–∞–Ω—è–µ–º —à–∞–±–ª–æ–Ω —Ä–∞—Å–ø–æ–ª–æ–∂–µ–Ω–∏—è
            saveLayoutTemplate();
        }
        function ensureRootCardExists() {
            let rootCard = canvas.querySelector('.card[data-id="root"]');
            if (!rootCard) {
                rootCard = document.createElement('div');
                rootCard.className = 'card';
                rootCard.dataset.id = 'root';
                rootCard.dataset.level = '0';
                rootCard.dataset.name = 'IVA';
                rootCard.dataset.uid = '0000001';
                rootCard.style.left = '2400px';
                rootCard.style.top = '200px';
                canvas.appendChild(rootCard);
            } else {
                if (!rootCard.dataset.level) rootCard.dataset.level = '0';
                if (!rootCard.dataset.name) rootCard.dataset.name = 'IVA';
                if (!rootCard.dataset.uid) rootCard.dataset.uid = '0000001';
                if (!rootCard.style.left) rootCard.style.left = '2400px';
                if (!rootCard.style.top) rootCard.style.top = '200px';
            }
            renderCardContents(rootCard);
            attachPoints(rootCard);
            enableDrag(rootCard);
            updatePointsState(rootCard);
            rootCard.dataset.directReferrals = rootCard.dataset.directReferrals || '0';
            rootCard.dataset.totalReferrals = rootCard.dataset.totalReferrals || '0';
            rootCard.dataset.bonusYellow = rootCard.dataset.bonusYellow || '0';
            rootCard.dataset.transitionRed = rootCard.dataset.transitionRed || '0';
            rootCard.dataset.payoutGreen = rootCard.dataset.payoutGreen || '0';
            rootCard.dataset.directInvites = rootCard.dataset.directInvites || rootCard.dataset.directReferrals || '0';
            return rootCard;
        }

        function loadPositions() {
            const saved = localStorage.getItem(STORAGE_KEY);
            if (!saved) return false;
            try {
                const data = JSON.parse(saved);
                if (!data.cards || data.cards.length === 0) {
                    console.warn('loadPositions: no saved cards found, fallback to default layout');
                    return false;
                }
                uidCounter = data.uidCounter || 1;
                // –û—á–∏—â–∞–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–µ –∫–∞—Ä—Ç–æ—á–∫–∏
                canvas.querySelectorAll('.card').forEach(card => card.remove());
                // –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º childMap
                childMap.clear();
                if (data.childMap) {
                    data.childMap.forEach(([parent, children]) => {
                        childMap.set(parent, new Set(children));
                    });
                }
                // –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∫–∞—Ä—Ç–æ—á–∫–∏
                const cardMap = new Map();
                data.cards.forEach(item => {
                    let card = canvas.querySelector(`.card[data-id="${item.id}"]`);
                    if (!card) {
                        card = document.createElement('div');
                        card.className = 'card';
                        card.dataset.id = item.id;
                        canvas.appendChild(card);
                    }
                    // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –≤—Å–µ –∞—Ç—Ä–∏–±—É—Ç—ã
                    if (item.parent) card.dataset.parent = item.parent;
                    // –ó–∞–≥—Ä—É–∂–∞–µ–º —É—Ä–æ–≤–µ–Ω—å –∏–∑ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö (–¥–ª—è root —Ç–æ–∂–µ)
                    let levelValue = 0;
                    if (item.level !== undefined && item.level !== null) {
                        if (typeof item.level === 'number') {
                            levelValue = item.level;
                        } else {
                            const parsed = parseInt(item.level, 10);
                            levelValue = Number.isNaN(parsed) ? 0 : parsed;
                        }
                    }
                    card.dataset.level = String(levelValue);
                    if (item.name) card.dataset.name = item.name;
                    if (item.uid) card.dataset.uid = item.uid;
                    if (item.directInvites !== undefined || item.totalReferrals !== undefined || card.dataset.directInvites !== undefined) {
                        const invitesValue = item.directInvites ?? card.dataset.directInvites ?? card.dataset.directReferrals ?? '0';
                        card.dataset.directInvites = String(invitesValue);
                    }
                    if (item.directReferrals !== undefined) {
                        card.dataset.directReferrals = String(item.directReferrals);
                    }
                    if (item.totalReferrals !== undefined) {
                        card.dataset.totalReferrals = String(item.totalReferrals);
                    }
                    if (item.bonusYellow !== undefined) {
                        card.dataset.bonusYellow = String(item.bonusYellow);
                    }
                    if (item.transitionRed !== undefined) {
                        card.dataset.transitionRed = String(item.transitionRed);
                    }
                    if (item.payoutGreen !== undefined) {
                        card.dataset.payoutGreen = String(item.payoutGreen);
                    }
                    card.style.left = item.left + 'px';
                    card.style.top = item.top + 'px';
                    // –†–µ–Ω–¥–µ—Ä–∏–º —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ
                    renderCardContents(card);
                    // –í–∫–ª—é—á–∞–µ–º drag –∏ —Ç–æ—á–∫–∏
                    enableDrag(card);
                    cardMap.set(item.id, card);
                });
                // –û–±–Ω–æ–≤–ª—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ —Ç–æ—á–µ–∫
                cardMap.forEach(card => {
                    updatePointsState(card);
                });
                updateAllConnections();
                
                isRestoringFromStorage = true;
                try {
                    recalculateAllLevels({
                        preserveRootLevel: true,
                        skipSave: true
                    });
                } finally {
                    isRestoringFromStorage = false;
                }

                // –ü–æ—Å–ª–µ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è –æ–±–Ω–æ–≤–ª—è–µ–º –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–µ –∫–∞—Ä—Ç–æ—á–µ–∫ —Å —É—á–µ—Ç–æ–º —Ñ–∏–Ω–∞–ª—å–Ω—ã—Ö —É—Ä–æ–≤–Ω–µ–π
                cardMap.forEach(card => {
                    renderCardContents(card);
                    attachPoints(card);
                    updatePointsState(card);
                });

                // –ì–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ–º –Ω–∞–ª–∏—á–∏–µ root –∫–∞—Ä—Ç–æ—á–∫–∏
                if (!cardMap.has('root')) {
                    const rootCard = document.createElement('div');
                    rootCard.className = 'card';
                    rootCard.dataset.id = 'root';
                    rootCard.dataset.level = '0';
                    rootCard.dataset.name = 'IVA';
                    rootCard.dataset.uid = '0000001';
                    rootCard.style.left = '2400px';
                    rootCard.style.top = '200px';
                    canvas.appendChild(rootCard);
                    renderCardContents(rootCard);
                    attachPoints(rootCard);
                    enableDrag(rootCard);
                    cardMap.set('root', rootCard);
                }
                
                // –ü–æ—Å–ª–µ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è –∏ –ø–µ—Ä–µ—Å—á—ë—Ç–∞ —Ñ–∏–∫—Å–∏—Ä—É–µ–º –∞–∫—Ç—É–∞–ª—å–Ω—ã–µ —É—Ä–æ–≤–Ω–∏
                savePositions();
                updateStats();
                return true;
            } catch (e) {
                console.error('Failed to load positions:', e);
                return false;
            }
        }

        function hydrateStructureFromPayload(payload, options = {}) {
            const {
                autoLayoutAfter = false,
                saveState = true,
                resetServerStats = false,
                recalcLevels = false,
            } = options;
            if (!payload || !Array.isArray(payload.cards)) {
                console.warn('hydrateStructureFromPayload: invalid payload', payload);
                return false;
            }
            const localDirectInvites = loadDirectInvitesFromLocalStorage();
            const rootCard = ensureRootCardExists();
            canvas.querySelectorAll('.card').forEach(card => {
                if (card !== rootCard) {
                    card.remove();
                }
            });
            childMap.clear();
            uidCounter = payload.uidCounter || payload.cards.length + 1;
            const cardMap = new Map();
            if (rootCard) {
                cardMap.set('root', rootCard);
            }

            payload.cards.forEach(item => {
                const isRootCard = item.id === 'root' && rootCard;
                let card = isRootCard ? rootCard : document.createElement('div');
                if (!isRootCard) {
                    card.className = 'card';
                    card.dataset.id = item.id || genId();
                    canvas.appendChild(card);
                }

                if (item.parent) {
                    card.dataset.parent = item.parent;
                } else {
                    delete card.dataset.parent;
                }
                const levelValue = typeof item.level === 'number'
                    ? item.level
                    : parseInt(card.dataset.level || '0', 10) || 0;
                card.dataset.level = String(levelValue);
                if (item.name) card.dataset.name = item.name;
                if (item.uid) card.dataset.uid = item.uid;
                const directInviteValue = (serverDirectInvites && serverDirectInvites[card.dataset.id] !== undefined)
                    ? parseInt(serverDirectInvites[card.dataset.id], 10)
                    : localDirectInvites.get(card.dataset.id) ?? parseInt(card.dataset.directInvites || '0', 10) ?? 0;
                card.dataset.directInvites = String(directInviteValue);
                if (item.status) card.dataset.status = item.status;
                if (item.rank !== undefined) card.dataset.rank = item.rank;
                card.dataset.directReferrals = String(
                    item.directReferrals ?? card.dataset.directReferrals ?? '0'
                );
                card.dataset.totalReferrals = String(
                    item.totalReferrals ?? card.dataset.totalReferrals ?? '0'
                );
                if (item.left !== undefined) card.style.left = item.left + 'px';
                if (item.top !== undefined) card.style.top = item.top + 'px';

                card.querySelectorAll('.point').forEach(point => point.remove());
                renderCardContents(card);
                attachPoints(card);
                enableDrag(card);
                cardMap.set(card.dataset.id, card);
            });

            if (payload.childMap && Array.isArray(payload.childMap)) {
                payload.childMap.forEach(entry => {
                    const [parentId, children] = entry;
                    childMap.set(parentId, new Set(children));
                });
            } else {
                cardMap.forEach(card => {
                    const parentId = card.dataset.parent;
                    if (!parentId) return;
                    if (!childMap.has(parentId)) {
                        childMap.set(parentId, new Set());
                    }
                    childMap.get(parentId).add(card.dataset.id);
                });
            }

            cardMap.forEach(card => updatePointsState(card));

            if (recalcLevels) {
                isRestoringFromStorage = true;
                try {
                    recalculateAllLevels({
                        preserveRootLevel: true,
                        skipSave: true,
                    });
                } finally {
                    isRestoringFromStorage = false;
                }
            }

            if (autoLayoutAfter) {
                autoLayoutCards();
            } else {
                updateAllConnections();
                if (saveState) {
                    savePositions();
                }
            }

            if (resetServerStats) {
                serverStructureStats = null;
            }
            Promise.resolve(
                recalculateAllLevels({ preserveRootLevel: true, skipSave: true })
            ).then(() => updateStats());
            return true;
        }

        function getChildSet(parentId) {
            if (!childMap.has(parentId)) childMap.set(parentId, new Set());
            return childMap.get(parentId);
        }
        function updatePointsState(card) {
            const pid = card.dataset.id;
            const count = (getChildSet(pid)).size;
            const disabled = count >= 3;
            card.querySelectorAll('.point').forEach(p => p.classList.toggle('disabled', disabled));
        }
        function incrementDirectInvites(card, amount = 1) {
            const current = parseInt(card.dataset.directInvites || card.dataset.directReferrals || '0', 10);
            card.dataset.directInvites = String(current + amount);
        }
        function attachPoints(card) {
            // –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—ã–µ —Ç–æ—á–∫–∏ –µ—Å–ª–∏ –µ—Å—Ç—å
            card.querySelectorAll('.point').forEach(p => p.remove());
            const left = document.createElement('div'); left.className = 'point left'; left.title = '–î–æ–±–∞–≤–∏—Ç—å —Å–ª–µ–≤–∞';
            const right = document.createElement('div'); right.className = 'point right'; right.title = '–î–æ–±–∞–≤–∏—Ç—å —Å–ø—Ä–∞–≤–∞';
            left.addEventListener('click', (e) => { e.stopPropagation(); createChild(card, 'left'); });
            right.addEventListener('click', (e) => { e.stopPropagation(); createChild(card, 'right'); });
            card.appendChild(left); card.appendChild(right);
            updatePointsState(card);
        }


        function createChild(parentCard, side, options = {}) {
            const {
                skipSave = false,
                skipStats = false,
            } = options;
            const parentId = parentCard.dataset.id;
            const children = getChildSet(parentId);
            if (children.size >= 3) return; // –ª–∏–º–∏—Ç

            const id = genId();
            const child = document.createElement('div');
            child.className = 'card';
            child.dataset.id = id;
            child.dataset.parent = parentId;
            child.dataset.level = '0'; // –ù–æ–≤—ã–µ –∫–∞—Ä—Ç–æ—á–∫–∏ —Å–æ–∑–¥–∞—é—Ç—Å—è —Å —É—Ä–æ–≤–Ω–µ–º 0
            // –ù–ï —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∏–º—è –∏ ID - –∫–∞—Ä—Ç–æ—á–∫–∞ —Å–æ–∑–¥–∞–µ—Ç—Å—è –ø—É—Å—Ç–æ–π
            const px = parseInt(parentCard.style.left) || 0;
            const py = parseInt(parentCard.style.top) || 0;
            const index = children.size; // 0..2
            
            // –ü—ã—Ç–∞–µ–º—Å—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã–π —à–∞–±–ª–æ–Ω —Ä–∞—Å–ø–æ–ª–æ–∂–µ–Ω–∏—è
            const template = loadLayoutTemplate(parentId);
            let nx, ny;
            
            if (template && template.length > index) {
                // –ò—Å–ø–æ–ª—å–∑—É–µ–º —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã–π —à–∞–±–ª–æ–Ω
                const templatePos = template[index];
                nx = px + templatePos.offsetX;
                ny = py + templatePos.offsetY;
            } else {
                // –ò—Å–ø–æ–ª—å–∑—É–µ–º —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—É—é –ª–æ–≥–∏–∫—É
                let dy = 120;
                const existing = Array.from(canvas.querySelectorAll(`.card[data-parent="${parentId}"]`));
                if (existing.length > 0) {
                    const base = py + 200;
                    const firstChild = existing[0];
                    const firstOffset = Math.abs((parseInt(firstChild.style.top) || 0) - base);
                    if (firstOffset > 0) dy = Math.max(40, Math.min(240, firstOffset));
                }
                const offsetMap = { 0: -240, 1: 0, 2: 240 };
                let indexOffset = offsetMap[Math.min(index, 2)];
                if (side === 'right' && index === 1) {
                    indexOffset = 240;
                } else if (side === 'left' && index === 1) {
                    indexOffset = -240;
                } else if (side === 'middle') {
                    indexOffset = 0;
                }
                const verticalLevels = [-dy, 0, dy];
                const baseY = py + 200;
                const vy = verticalLevels[Math.min(index, 2)];
                if (side === 'middle') {
                    nx = px;
                } else {
                    nx = px + indexOffset;
                }
                ny = baseY + vy;
            }
            
            // –ü—Ä–∏–≤—è–∑–∫–∞ –∫ —Å–µ—Ç–∫–µ
            const snappedX = Math.round(nx / GRID_SIZE) * GRID_SIZE;
            const snappedY = Math.round(ny / GRID_SIZE) * GRID_SIZE;
            child.style.left = snappedX + 'px';
            child.style.top = snappedY + 'px';
            renderCardContents(child);
            canvas.appendChild(child);
            attachPoints(child);
            enableDrag(child);
            child.dataset.directReferrals = child.dataset.directReferrals || '0';
            child.dataset.totalReferrals = child.dataset.totalReferrals || '0';
            child.dataset.bonusYellow = child.dataset.bonusYellow || '0';
            child.dataset.transitionRed = child.dataset.transitionRed || '0';
            child.dataset.payoutGreen = child.dataset.payoutGreen || '0';
            child.dataset.directInvites = child.dataset.directInvites || '0';
            children.add(id);
            updatePointsState(parentCard);
            updateConnectionFor(child);
            if (!skipSave) {
                savePositions();
            }
            if (!skipStats) {
                updateStats();
            }
            return child;
        }

        // –£–¥–∞–ª–µ–Ω–∏–µ –∫–∞—Ä—Ç–æ—á–∫–∏ –∏ –≤—Å–µ—Ö –µ—ë –¥–æ—á–µ—Ä–Ω–∏—Ö –∫–∞—Ä—Ç–æ—á–µ–∫ (—Ä–µ–∫—É—Ä—Å–∏–≤–Ω–æ)
        function deleteCardAndChildren(card) {
            if (!card || card.dataset.id === 'root') return; // –ù–µ —É–¥–∞–ª—è–µ–º root
            
            const cardId = card.dataset.id;
            
            // –ù–∞—Ö–æ–¥–∏–º –≤—Å–µ—Ö –¥–µ—Ç–µ–π —ç—Ç–æ–π –∫–∞—Ä—Ç–æ—á–∫–∏
            const children = Array.from(canvas.querySelectorAll(`.card[data-parent="${cardId}"]`));
            
            // –†–µ–∫—É—Ä—Å–∏–≤–Ω–æ —É–¥–∞–ª—è–µ–º –≤—Å–µ—Ö –¥–µ—Ç–µ–π
            children.forEach(child => {
                deleteCardAndChildren(child);
            });
            
            // –£–¥–∞–ª—è–µ–º —Å–≤—è–∑–∏ (SVG –ø—É—Ç–∏)
            const linkGroup = document.getElementById('link-' + cardId);
            if (linkGroup) linkGroup.remove();
            
            // –£–¥–∞–ª—è–µ–º –∫–∞—Ä—Ç–æ—á–∫—É –∏–∑ childMap —Ä–æ–¥–∏—Ç–µ–ª—è
            const parentId = card.dataset.parent;
            if (parentId && childMap.has(parentId)) {
                childMap.get(parentId).delete(cardId);
            }
            
            // –£–¥–∞–ª—è–µ–º –∫–∞—Ä—Ç–æ—á–∫—É –∏–∑ DOM
            card.remove();
            
            // –û–±–Ω–æ–≤–ª—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ —Ç–æ—á–µ–∫ —Ä–æ–¥–∏—Ç–µ–ª—è
            if (parentId) {
                const parentCard = canvas.querySelector(`.card[data-id="${parentId}"]`);
                if (parentCard) {
                    updatePointsState(parentCard);
                }
            }
            
            // –û–±–Ω–æ–≤–ª—è–µ–º —Å–≤—è–∑–∏ –∏ —Å–æ—Ö—Ä–∞–Ω—è–µ–º
            recalculateAllLevels();
            autoLayoutCards();

            savePositions();
            updateStats();
        }

        // Drag –∫–∞—Ä—Ç–æ—á–µ–∫
        let dragging = null;
        let dragOffsetX = 0, dragOffsetY = 0;
        let startLeft = 0, startTop = 0;

        function toCanvasCoords(clientX, clientY) {
            const rect = viewport.getBoundingClientRect();
            const x = (clientX - rect.left - offsetX) / scale;
            const y = (clientY - rect.top - offsetY) / scale;
            return { x, y };
        }

        function enableDrag(card) {
            attachPoints(card);
            card.addEventListener('mousedown', (e) => {
                if ((e.target).classList && (e.target).classList.contains('point')) return;
                // –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø–∞–Ω–æ—Ä–∞–º–∏—Ä–æ–≤–∞–Ω–∏–µ –ø—Ä–∏ –Ω–∞—á–∞–ª–µ drag –∫–∞—Ä—Ç–æ—á–∫–∏
                isPanning = false;
                dragging = card;
                dragging.classList.add('dragging');
                const { x, y } = toCanvasCoords(e.clientX, e.clientY);
                startLeft = parseInt(card.style.left) || 0;
                startTop = parseInt(card.style.top) || 0;
                dragOffsetX = x - startLeft;
                dragOffsetY = y - startTop;
                e.preventDefault();
                e.stopPropagation(); // –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –≤—Å–ø–ª—ã—Ç–∏–µ —Å–æ–±—ã—Ç–∏—è
            });
        }

        window.addEventListener('mousemove', (e) => {
            if (!dragging) return;
            const { x, y } = toCanvasCoords(e.clientX, e.clientY);
            const nx = x - dragOffsetX;
            const ny = y - dragOffsetY;
            dragging.style.left = nx + 'px';
            dragging.style.top = ny + 'px';
            updateConnectionsForCardAndRelatives(dragging);
        });
        window.addEventListener('mouseup', () => {
            if (!dragging) return;
            // –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø–∞–Ω–æ—Ä–∞–º–∏—Ä–æ–≤–∞–Ω–∏–µ
            isPanning = false;
            if (snapEnabled) {
                const nx = Math.round((parseInt(dragging.style.left) || 0) / GRID_SIZE) * GRID_SIZE;
                const ny = Math.round((parseInt(dragging.style.top) || 0) / GRID_SIZE) * GRID_SIZE;
                dragging.style.left = nx + 'px';
                dragging.style.top = ny + 'px';
            }
            dragging.classList.remove('dragging');
            const finished = dragging;
            dragging = null;
            if (finished) {
                updateConnectionsForCardAndRelatives(finished);
                savePositions(); // –≠—Ç–æ —Ç–∞–∫–∂–µ —Å–æ—Ö—Ä–∞–Ω–∏—Ç —à–∞–±–ª–æ–Ω —Ä–∞—Å–ø–æ–ª–æ–∂–µ–Ω–∏—è
                updateStats();
            }
        });

        // –°–æ–∑–¥–∞–Ω–∏–µ root –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –≤ –±–∞–∑–µ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ
        async function ensureRootInDatabase() {
            const rootCard = canvas.querySelector('.card[data-id="root"]');
            if (!rootCard) return;
            rootCard.dataset.directReferrals = '0';
            rootCard.dataset.totalReferrals = '0';
            rootCard.dataset.bonusYellow = '0';
            rootCard.dataset.transitionRed = '0';
            rootCard.dataset.payoutGreen = '0';
            rootCard.dataset.directInvites = '0';
            
            if (!rootCard.dataset.name) rootCard.dataset.name = 'IVA';
            if (!rootCard.dataset.uid) rootCard.dataset.uid = '0000001';
            
            // –°–æ—Ö—Ä–∞–Ω—è–µ–º root –≤ –±–∞–∑—É –µ—Å–ª–∏ –µ–≥–æ —Ç–∞–º –Ω–µ—Ç
            try {
                await saveCardToDatabase(rootCard);
            } catch (error) {
                console.error('–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è root –≤ –±–∞–∑—É:', error);
            }
        }
        
        async function initializeStructureCanvas() {
            let loadedFromServer = false;
            try {
                loadedFromServer = await fetchStructureFromServer();
            } catch (error) {
                console.warn('–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Å—Ç—Ä—É–∫—Ç—É—Ä—É –ø—Ä–∏ —Å—Ç–∞—Ä—Ç–µ', error);
            }

            if (!loadedFromServer) {
                serverStructureStats = null;
                if (!loadPositions()) {
                    canvas.querySelectorAll('.card').forEach(card => {
                        if (card.dataset.id !== 'root') {
                            card.remove();
                        }
                    });
                    childMap.clear();
                    const root = canvas.querySelector('.card[data-id="root"]');
                    if (root) {
                        if (!root.dataset.level) root.dataset.level = '0';
                        if (!root.dataset.name) root.dataset.name = 'IVA';
                        if (!root.dataset.uid) root.dataset.uid = '0000001';
                        renderCardContents(root);
                        enableDrag(root);
                    }
                }
            }
            
            const rootCard = ensureRootCardExists();
            if (rootCard) {
                renderCardContents(rootCard);
            }
            updateAllConnections();
            updateStats();

            await ensureRootInDatabase();

            canvas.querySelectorAll('.card').forEach(card => {
                if (!card.querySelector('.badge')) {
                    renderCardContents(card);
                }
            });
            if (canvas.querySelectorAll('.card').length > 1) {
                showAllCards();
            } else if (btnCenter) {
                btnCenter.click();
            } else {
                applyTransform();
            }
            updateStats();
            initGuideLines();
        }

        initializeStructureCanvas();

        // ----- –°–≤—è–∑–∏ (–∫–∞–∫ –≤ Miro): –≥–∏–±–∫–∏–µ –∫—Ä–∏–≤—ã–µ, —Å–ª–µ–¥—É—é—Ç –∑–∞ –∫–∞—Ä—Ç–æ—á–∫–∞–º–∏ -----
        function getAnchorBottom(card) {
            const left = parseInt(card.style.left) || 0;
            const top = parseInt(card.style.top) || 0;
            const width = Math.max(card.offsetWidth, 160);
            const height = Math.max(card.offsetHeight, 80);
            return { x: left + width / 2, y: top + height };
        }
        function getAnchorTop(card) {
            const left = parseInt(card.style.left) || 0;
            const top = parseInt(card.style.top) || 0;
            const width = Math.max(card.offsetWidth, 160);
            return { x: left + width / 2, y: top };
        }
        function pathCubic(start, end) {
            const dy = Math.max(60, Math.abs(end.y - start.y) * 0.5);
            const c1 = { x: start.x, y: start.y + dy };
            const c2 = { x: end.x, y: end.y - dy };
            return `M ${start.x} ${start.y} C ${c1.x} ${c1.y}, ${c2.x} ${c2.y}, ${end.x} ${end.y}`;
        }
        function ensureLinkPath(id) {
            let g = document.getElementById('link-' + id);
            if (!g) {
                g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                g.setAttribute('id', 'link-' + id);
                const shadow = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                shadow.setAttribute('class', 'link-shadow');
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('class', 'link-path');
                g.appendChild(shadow);
                g.appendChild(path);
                links.appendChild(g);
            }
            return g;
        }
        function updateConnectionFor(childCard) {
            const parentId = childCard.dataset.parent;
            if (!parentId) return;
            const parentCard = canvas.querySelector(`.card[data-id="${parentId}"]`);
            if (!parentCard) return;
            const start = getAnchorBottom(parentCard);
            const end = getAnchorTop(childCard);
            const d = pathCubic(start, end);
            const g = ensureLinkPath(childCard.dataset.id);
            g.firstChild.setAttribute('d', d);
            g.lastChild.setAttribute('d', d);
        }
        function updateConnectionsForCardAndRelatives(card) {
            // –û–±–Ω–æ–≤–ª—è–µ–º —Å–≤—è–∑—å –∫ —Ä–æ–¥–∏—Ç–µ–ª—é
            updateConnectionFor(card);
            // –ò —Å–≤—è–∑–∏ –∫–æ –≤—Å–µ–º –¥–µ—Ç—è–º
            const id = card.dataset.id;
            canvas.querySelectorAll(`.card[data-parent="${id}"]`).forEach(updateConnectionFor);
        }
        function updateAllConnections() {
            canvas.querySelectorAll('.card[data-parent]').forEach(updateConnectionFor);
        }
        // –Ω–∞—á–∞–ª—å–Ω–æ–µ –ø–æ—Å—Ç—Ä–æ–µ–Ω–∏–µ (–¥–ª—è root –¥–µ—Ç–µ–π –ø–æ–∫–∞ –Ω–µ—Ç)
        updateAllConnections();

        // –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è —Ä–∞—Å—Å—Ç–∞–Ω–æ–≤–∫–∞ –∫–∞—Ä—Ç–æ—á–µ–∫ –±–µ–∑ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–π
        function autoLayoutCards() {
            const cards = Array.from(canvas.querySelectorAll('.card'));
            if (cards.length === 0) return;

            const CARD_WIDTH = 160;
            const CARD_HEIGHT = 80;
            const VERTICAL_GAP = 220;
            const GRID_SIZE = 40;
            const TOP_MARGIN = 120;
            const NODE_GAP_X = 40;
            const SUBTREE_MARGIN = 40;
            const CANVAS_WIDTH = 6500;

            const nodeMap = new Map();
            const parentOf = new Map();
            cards.forEach(card => {
                const id = card.dataset.id;
                nodeMap.set(id, { card, children: [] });
                const parentId = card.dataset.parent || null;
                if (parentId) {
                    parentOf.set(id, parentId);
                }
            });

            nodeMap.forEach((node, id) => {
                const parentId = parentOf.get(id);
                if (parentId && nodeMap.has(parentId)) {
                    nodeMap.get(parentId).children.push(id);
                }
            });

            nodeMap.forEach(node => {
                node.children.sort((a, b) => {
                    const aCard = nodeMap.get(a)?.card;
                    const bCard = nodeMap.get(b)?.card;
                    const aLeft = aCard ? parseInt(aCard.style.left) || 0 : 0;
                    const bLeft = bCard ? parseInt(bCard.style.left) || 0 : 0;
                    if (aLeft !== bLeft) return aLeft - bLeft;
                    return a.localeCompare(b);
                });
            });

            let roots = [];
            nodeMap.forEach((_, id) => {
                if (!parentOf.has(id)) {
                    roots.push(id);
                }
            });
            if (roots.length === 0) return;

            const MIN_SUBTREE_WIDTH = CARD_WIDTH + SUBTREE_MARGIN * 2;
            const subtreeWidth = new Map();

            function measureSubtree(id) {
                const node = nodeMap.get(id);
                if (!node) {
                    return MIN_SUBTREE_WIDTH;
                }
                if (!node.children.length) {
                    subtreeWidth.set(id, MIN_SUBTREE_WIDTH);
                    return MIN_SUBTREE_WIDTH;
                }
                let total = 0;
                node.children.forEach((childId, index) => {
                    const childWidth = measureSubtree(childId);
                    total += childWidth;
                    if (index < node.children.length - 1) {
                        total += NODE_GAP_X;
                    }
                });
                total = Math.max(total, MIN_SUBTREE_WIDTH);
                subtreeWidth.set(id, total);
                return total;
            }

            roots.forEach(rootId => measureSubtree(rootId));

            const rootGap = 200;
            let totalRootsWidth = 0;
            roots.forEach((rootId, index) => {
                const w = subtreeWidth.get(rootId) || MIN_SUBTREE_WIDTH;
                totalRootsWidth += w;
                if (index < roots.length - 1) {
                    totalRootsWidth += rootGap;
                }
            });
            let currentLeft = Math.max((CANVAS_WIDTH - totalRootsWidth) / 2, SUBTREE_MARGIN);

            function layoutSubtree(id, depth, left) {
                const node = nodeMap.get(id);
                if (!node) return;
                const width = subtreeWidth.get(id) || MIN_SUBTREE_WIDTH;
                const centerX = left + width / 2;
                const y = TOP_MARGIN + depth * (CARD_HEIGHT + VERTICAL_GAP);
                const snappedX = Math.round((centerX - CARD_WIDTH / 2) / GRID_SIZE) * GRID_SIZE;
                const snappedY = Math.round(y / GRID_SIZE) * GRID_SIZE;
                node.card.style.left = snappedX + 'px';
                node.card.style.top = snappedY + 'px';

                if (!node.children.length) {
                    return;
                }
                let childLeft = left;
                node.children.forEach((childId, index) => {
                    const childWidth = subtreeWidth.get(childId) || MIN_SUBTREE_WIDTH;
                    layoutSubtree(childId, depth + 1, childLeft);
                    childLeft += childWidth;
                    if (index < node.children.length - 1) {
                        childLeft += NODE_GAP_X;
                    }
                });
            }

            roots.forEach((rootId, index) => {
                const width = subtreeWidth.get(rootId) || MIN_SUBTREE_WIDTH;
                layoutSubtree(rootId, 0, currentLeft);
                currentLeft += width;
                if (index < roots.length - 1) {
                    currentLeft += rootGap;
                }
            });

            updateAllConnections();
            savePositions();
            updateStats();
            setTimeout(() => {
                if (typeof showAllCards === 'function') {
                    showAllCards();
                } else if (btnCenter) {
                    btnCenter.click();
                } else {
                    applyTransform();
                }
            }, 100);
        }

        btnAutoLayout.onclick = () => autoLayoutCards();

        // –ü–æ–¥—Å—á–µ—Ç —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –ø–æ —É—Ä–æ–≤–Ω—è–º - —Å—á–∏—Ç–∞–µ–º –ø–∞—Ä—Ç–Ω–µ—Ä–æ–≤ –ø–µ—Ä–≤–æ–≥–æ –∞–∫–∫–∞—É–Ω—Ç–∞ (root)
        function updateStats() {
            const cards = Array.from(canvas.querySelectorAll('.card'));
            const rootCard = cards.find(card => card.dataset.id === 'root');
            
            if (!rootCard) {
                statsContent.innerHTML = '<div class="stats-item">–ù–µ—Ç root –∫–∞—Ä—Ç–æ—á–∫–∏</div>';
                return;
            }
            if (serverStructureStats) {
                const domFilledCount = cards.filter(isCardFilled).length;
                const domDirectInvites = parseInt(rootCard.dataset.directInvites || rootCard.dataset.directReferrals || '0', 10);
                const serverNodes = parseInt(serverStructureStats?.totals?.nodes ?? '0', 10);
                const serverDirect = parseInt(serverStructureStats?.root?.direct_referrals ?? '0', 10);
                if (serverNodes === domFilledCount && serverDirect === domDirectInvites) {
                    renderStatsFromServer(serverStructureStats);
                    return;
                }
                serverStructureStats = null;
            }
            const directReferralsRoot = parseInt(
                rootCard.dataset.directInvites || rootCard.dataset.directReferrals || '0',
                10
            );
            const totalReferralsRoot = parseInt(rootCard.dataset.totalReferrals || '0', 10);
            const bonusYellowRoot = parseFloat(rootCard.dataset.bonusYellow || '0');
            const transitionRedRoot = parseFloat(rootCard.dataset.transitionRed || '0');
            const payoutGreenRoot = parseFloat(rootCard.dataset.payoutGreen || '0');
            
            // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –ø—Ä—è–º—ã—Ö –¥–µ—Ç–µ–π –∫–∞—Ä—Ç–æ—á–∫–∏
            function getDirectChildren(parentId) {
                return Array.from(canvas.querySelectorAll(`.card[data-parent="${parentId}"]`));
            }
            
            // –î–ª—è –∫–∞–∂–¥–æ–≥–æ —É—Ä–æ–≤–Ω—è —Å—á–∏—Ç–∞–µ–º –ø–∞—Ä—Ç–Ω–µ—Ä–æ–≤ root (—Ç–æ–ª—å–∫–æ –ø—Ä—è–º—ã–µ –¥–µ—Ç–∏ –ø—Ä–µ–¥—ã–¥—É—â–µ–≥–æ —É—Ä–æ–≤–Ω—è)
            const levelStats = {};
            const cardsByLevel = {}; // –ö—ç—à –∫–∞—Ä—Ç–æ—á–µ–∫ –ø–æ —É—Ä–æ–≤–Ω—è–º
            
            // –ù–∞—Ö–æ–¥–∏–º –º–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π —É—Ä–æ–≤–µ–Ω—å —Å—Ä–µ–¥–∏ –≤—Å–µ—Ö –∫–∞—Ä—Ç–æ—á–µ–∫
            let maxLevel = 0;
            cards.forEach(card => {
                const level = parseInt(card.dataset.level || '0');
                if (level > maxLevel) maxLevel = level;
                if (!cardsByLevel[level]) cardsByLevel[level] = [];
                cardsByLevel[level].push(card);
            });
            
            // –ù–∞—á–∏–Ω–∞–µ–º —Å —É—Ä–æ–≤–Ω—è root
            const rootLevel = parseInt(rootCard.dataset.level || '0');
            
            // –î–ª—è root —Å—á–∏—Ç–∞–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –ø–æ –≤—Å–µ–º —É—Ä–æ–≤–Ω—è–º –ø–∞—Ä—Ç–Ω–µ—Ä–æ–≤
            // –õ–æ–≥–∏–∫–∞: –¥–ª—è –∫–∞–∂–¥–æ–≥–æ —É—Ä–æ–≤–Ω—è –ø–∞—Ä—Ç–Ω–µ—Ä–æ–≤ —Å—á–∏—Ç–∞–µ–º –∏—Ö –ø—Ä—è–º—ã—Ö –¥–µ—Ç–µ–π —Ç–æ–≥–æ –∂–µ —É—Ä–æ–≤–Ω—è
            // –ù–∞–ø—Ä–∏–º–µ—Ä, –¥–ª—è –ø–æ–≤—ã—à–µ–Ω–∏—è 3 –ø–∞—Ä—Ç–Ω–µ—Ä–æ–≤ —É—Ä–æ–≤–Ω—è 0 –¥–æ —É—Ä–æ–≤–Ω—è 1 –Ω—É–∂–Ω–æ 9 –ø–∞—Ä—Ç–Ω–µ—Ä–æ–≤ —É—Ä–æ–≤–Ω—è 0 (–ø–æ 3 –Ω–∞ –∫–∞–∂–¥–æ–≥–æ)
            const rootPartnersByLevel = {};
            const partnersMaxByLevel = {};
            
            // –°–Ω–∞—á–∞–ª–∞ –Ω–∞—Ö–æ–¥–∏–º –≤—Å–µ—Ö –ø—Ä—è–º—ã—Ö –¥–µ—Ç–µ–π root –∏ –≥—Ä—É–ø–ø–∏—Ä—É–µ–º –∏—Ö –ø–æ —É—Ä–æ–≤–Ω—è–º
            const rootDirectChildren = getDirectChildren('root').filter(card => card.dataset.name && card.dataset.uid);
            rootDirectChildren.forEach(partner => {
                const partnerLevel = parseInt(partner.dataset.level || '0');
                if (!rootPartnersByLevel[partnerLevel]) {
                    rootPartnersByLevel[partnerLevel] = new Set();
                }
                rootPartnersByLevel[partnerLevel].add(partner.dataset.id);
            });
            
            // –î–ª—è –∫–∞–∂–¥–æ–≥–æ —É—Ä–æ–≤–Ω—è –ø–∞—Ä—Ç–Ω–µ—Ä–æ–≤ root —Å—á–∏—Ç–∞–µ–º –∏—Ö –ø—Ä—è–º—ã—Ö –¥–µ—Ç–µ–π —Ç–æ–≥–æ –∂–µ —É—Ä–æ–≤–Ω—è
            // –ù–∞–ø—Ä–∏–º–µ—Ä, –¥–ª—è –ø–æ–≤—ã—à–µ–Ω–∏—è 3 –ø–∞—Ä—Ç–Ω–µ—Ä–æ–≤ —É—Ä–æ–≤–Ω—è 0 –¥–æ —É—Ä–æ–≤–Ω—è 1 –Ω—É–∂–Ω–æ 9 –ø–∞—Ä—Ç–Ω–µ—Ä–æ–≤ —É—Ä–æ–≤–Ω—è 0 (–ø–æ 3 –Ω–∞ –∫–∞–∂–¥–æ–≥–æ)
            Object.keys(rootPartnersByLevel).forEach(levelStr => {
                const level = parseInt(levelStr);
                const targetLevel = level; // –£—Ä–æ–≤–µ–Ω—å –¥–µ—Ç–µ–π –¥–ª—è –ø–æ–≤—ã—à–µ–Ω–∏—è –ø–∞—Ä—Ç–Ω–µ—Ä–æ–≤ —É—Ä–æ–≤–Ω—è level (—Ç–æ—Ç –∂–µ —É—Ä–æ–≤–µ–Ω—å!)
                
                // –ù–∞—Ö–æ–¥–∏–º –≤—Å–µ—Ö –ø–∞—Ä—Ç–Ω–µ—Ä–æ–≤ root —É—Ä–æ–≤–Ω—è level
                const partnersAtLevel = Array.from(rootPartnersByLevel[level]).map(id => 
                    canvas.querySelector(`.card[data-id="${id}"]`)
                ).filter(card => card);
                
                if (partnersAtLevel.length === 0) return; // –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –µ—Å–ª–∏ –Ω–µ—Ç –ø–∞—Ä—Ç–Ω–µ—Ä–æ–≤
                
                // –î–ª—è –∫–∞–∂–¥–æ–≥–æ –ø–∞—Ä—Ç–Ω–µ—Ä–∞ —É—Ä–æ–≤–Ω—è level –Ω–∞—Ö–æ–¥–∏–º –µ–≥–æ –ø—Ä—è–º—ã—Ö –¥–µ—Ç–µ–π —É—Ä–æ–≤–Ω—è targetLevel (—Ç–æ–≥–æ –∂–µ —É—Ä–æ–≤–Ω—è)
                const childrenAtTargetLevel = new Set();
                partnersAtLevel.forEach(partner => {
                    const directChildren = getDirectChildren(partner.dataset.id)
                        .filter(child => child.dataset.name && child.dataset.uid);
                    directChildren.forEach(child => {
                        const childLevel = parseInt(child.dataset.level || '0');
                        if (childLevel === targetLevel) {
                            childrenAtTargetLevel.add(child.dataset.id);
                        }
                    });
                });
                
                // –ú–∞–∫—Å–∏–º—É–º = –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–∞—Ä—Ç–Ω–µ—Ä–æ–≤ —É—Ä–æ–≤–Ω—è level * 3
                partnersMaxByLevel[targetLevel] = partnersAtLevel.length * 3;
                
                // –°–æ—Ö—Ä–∞–Ω—è–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–∞—Ä—Ç–Ω–µ—Ä–æ–≤ —É—Ä–æ–≤–Ω—è targetLevel –¥–ª—è –ø–æ–≤—ã—à–µ–Ω–∏—è –ø–∞—Ä—Ç–Ω–µ—Ä–æ–≤ —É—Ä–æ–≤–Ω—è level
                // –î–ª—è —É—Ä–æ–≤–Ω—è 0: –ø–µ—Ä–µ–∑–∞–ø–∏—Å—ã–≤–∞–µ–º rootPartnersByLevel[0] —Ç–æ–ª—å–∫–æ –¥–µ—Ç—å–º–∏ –ø–∞—Ä—Ç–Ω–µ—Ä–æ–≤ —É—Ä–æ–≤–Ω—è 0
                // –î–ª—è –¥—Ä—É–≥–∏—Ö —É—Ä–æ–≤–Ω–µ–π: –¥–æ–±–∞–≤–ª—è–µ–º –≤ rootPartnersByLevel[targetLevel]
                if (level === 0) {
                    // –î–ª—è —É—Ä–æ–≤–Ω—è 0: —Å–æ—Ö—Ä–∞–Ω—è–µ–º —Ç–æ–ª—å–∫–æ –¥–µ—Ç–µ–π –ø–∞—Ä—Ç–Ω–µ—Ä–æ–≤ —É—Ä–æ–≤–Ω—è 0 (–Ω–µ —Å–∞–º–∏—Ö –ø–∞—Ä—Ç–Ω–µ—Ä–æ–≤)
                    rootPartnersByLevel[0] = childrenAtTargetLevel;
                } else {
                    // –î–ª—è –¥—Ä—É–≥–∏—Ö —É—Ä–æ–≤–Ω–µ–π: –¥–æ–±–∞–≤–ª—è–µ–º –¥–µ—Ç–µ–π –≤ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–π —É—Ä–æ–≤–µ–Ω—å
                    if (!rootPartnersByLevel[targetLevel]) {
                        rootPartnersByLevel[targetLevel] = new Set();
                    }
                    childrenAtTargetLevel.forEach(id => {
                        rootPartnersByLevel[targetLevel].add(id);
                    });
                }
            });
            
            // –î–ª—è –ø–æ–≤—ã—à–µ–Ω–∏—è root –Ω—É–∂–Ω—ã 3 –ø–∞—Ä—Ç–Ω–µ—Ä–∞ —É—Ä–æ–≤–Ω—è rootLevel
            const rootPartnersAtRootLevel = rootPartnersByLevel[rootLevel] || new Set();
            const rootNeededForNextLevel = Math.max(0, 3 - rootPartnersAtRootLevel.size);
            const nextLevel = rootLevel + 1;
            
            levelStats[rootLevel] = {
                total: 1,
                filled: 1,
                max: 0,
                neededForNextLevel: rootNeededForNextLevel,
                partnersAtLevel: rootPartnersAtRootLevel.size,
                partnersByLevel: rootPartnersByLevel,
                partnersMaxByLevel: partnersMaxByLevel,
                currentLevel: rootLevel,
                nextLevel: nextLevel
            };
            
            // –î–ª—è —É—Ä–æ–≤–Ω–µ–π –≤—ã—à–µ root —Å—á–∏—Ç–∞–µ–º –ø–∞—Ä—Ç–Ω–µ—Ä–æ–≤ —É—Ä–æ–≤–Ω—è (level - 1) –¥–ª—è –ø–æ–≤—ã—à–µ–Ω–∏—è –∫–∞—Ä—Ç–æ—á–µ–∫ —É—Ä–æ–≤–Ω—è level
            for (let level = rootLevel + 1; level <= maxLevel; level++) {
                const prevLevel = level - 1;
                const prevLevelCards = cardsByLevel[prevLevel] || [];
                
                // –°–æ–±–∏—Ä–∞–µ–º –≤—Å–µ—Ö –ø—Ä—è–º—ã—Ö –¥–µ—Ç–µ–π –∫–∞—Ä—Ç–æ—á–µ–∫ –ø—Ä–µ–¥—ã–¥—É—â–µ–≥–æ —É—Ä–æ–≤–Ω—è (—ç—Ç–æ –∫–∞—Ä—Ç–æ—á–∫–∏ —É—Ä–æ–≤–Ω—è level)
                const levelCards = [];
                prevLevelCards.forEach(parentCard => {
                    const children = getDirectChildren(parentCard.dataset.id);
                    levelCards.push(...children);
                });
                
                // –£–±–∏—Ä–∞–µ–º –¥—É–±–ª–∏–∫–∞—Ç—ã –ø–æ ID
                const uniqueCards = [];
                const seenIds = new Set();
                levelCards.forEach(card => {
                    if (!seenIds.has(card.dataset.id)) {
                        seenIds.add(card.dataset.id);
                        uniqueCards.push(card);
                    }
                });
                
                cardsByLevel[level] = uniqueCards;
                const filledCards = uniqueCards.filter(card => card.dataset.name && card.dataset.uid);
                
                // –î–ª—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ —Å—á–∏—Ç–∞–µ–º –ø–∞—Ä—Ç–Ω–µ—Ä–æ–≤ —É—Ä–æ–≤–Ω—è (level - 1) –¥–ª—è –∫–∞—Ä—Ç–æ—á–µ–∫ —É—Ä–æ–≤–Ω—è level
                // –≠—Ç–æ –ø–∞—Ä—Ç–Ω–µ—Ä—ã, –∫–æ—Ç–æ—Ä—ã–µ –Ω—É–∂–Ω—ã –¥–ª—è –ø–æ–≤—ã—à–µ–Ω–∏—è –∫–∞—Ä—Ç–æ—á–µ–∫ —É—Ä–æ–≤–Ω—è level –¥–æ —É—Ä–æ–≤–Ω—è (level + 1)
                const targetPartnerLevel = level - 1;
                const uniquePartnersAtTargetLevel = new Set();
                
                filledCards.forEach(card => {
                    const cardPartners = getDirectChildren(card.dataset.id)
                        .filter(p => p.dataset.name && p.dataset.uid);
                    
                    // –î–æ–±–∞–≤–ª—è–µ–º –ø–∞—Ä—Ç–Ω–µ—Ä–æ–≤ —É—Ä–æ–≤–Ω—è targetPartnerLevel –≤ Set (—É–Ω–∏–∫–∞–ª—å–Ω–æ—Å—Ç—å –ø–æ ID)
                    cardPartners.forEach(partner => {
                        const partnerLevel = parseInt(partner.dataset.level || '0');
                        if (partnerLevel === targetPartnerLevel) {
                            uniquePartnersAtTargetLevel.add(partner.dataset.id);
                        }
                    });
                });
                
                // –ú–∞–∫—Å–∏–º—É–º –ø–∞—Ä—Ç–Ω–µ—Ä–æ–≤ = –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∫–∞—Ä—Ç–æ—á–µ–∫ —É—Ä–æ–≤–Ω—è level * 3
                const maxPartners = filledCards.length * 3;
                const partnersAtTargetLevelCount = uniquePartnersAtTargetLevel.size;
                const neededForNextLevel = Math.max(0, maxPartners - partnersAtTargetLevelCount);
                
                levelStats[level] = {
                    total: uniqueCards.length,
                    filled: filledCards.length,
                    max: maxPartners,
                    partnersAtLevel: partnersAtTargetLevelCount,
                    neededForNextLevel: neededForNextLevel,
                    targetPartnerLevel: targetPartnerLevel
                };
            }
            
            // –°—É–º–º–∞—Ä–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –ø–æ —É—Ä–æ–≤–Ω—è–º
            const summaryLevels = Object.keys(cardsByLevel).map(levelStr => {
                const level = parseInt(levelStr);
                const total = (cardsByLevel[level] || []).length;
                const filled = (cardsByLevel[level] || []).filter(card => card.dataset.name && card.dataset.uid).length;
                return { level, total, filled };
            }).sort((a, b) => a.level - b.level);
            const overallTotals = summaryLevels.reduce((acc, item) => {
                acc.total += item.total;
                acc.filled += item.filled;
                return acc;
            }, { total: 0, filled: 0 });
            const totalLevelsCount = summaryLevels.filter(item => item.total > 0).length;
            
            const requirementsSummary = {};
            const requirementDetails = [];
            
            // –§–æ—Ä–º–∏—Ä—É–µ–º HTML –æ—Ç –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–≥–æ —É—Ä–æ–≤–Ω—è –¥–æ root —É—Ä–æ–≤–Ω—è
            let htmlDetails = '';
            for (let level = maxLevel; level >= rootLevel; level--) {
                const stats = levelStats[level];
                if (!stats) continue;
                
                if (level === rootLevel) {
                    // Root –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç –¥–µ—Ç–∞–ª—å–Ω—É—é —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
                    const currentLevel = stats.currentLevel || rootLevel;
                    const nextLevel = stats.nextLevel || (rootLevel + 1);
                    const needed = stats.neededForNextLevel || 0;
                    const partnersAtLevel = stats.partnersAtLevel || 0;
                    const partnersByLevel = stats.partnersByLevel || {};
                    const partnersMaxByLevel = stats.partnersMaxByLevel || {};
                    const totalRootLevelCards = (cardsByLevel[rootLevel] || []).length;
                    const filledRootLevelCards = (cardsByLevel[rootLevel] || []).filter(card => card.dataset.name && card.dataset.uid).length;
                    
                    // –§–æ—Ä–º–∏—Ä—É–µ–º –¥–µ—Ç–∞–ª—å–Ω—É—é —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
                    let htmlRoot = '';
                    
                    // –¢–µ–∫—É—â–∏–π —É—Ä–æ–≤–µ–Ω—å (–ø–æ–∫–∞–∑—ã–≤–∞–µ–º –ø–µ—Ä–≤—ã–º)
                    htmlRoot += `<div class="stats-item" style="margin-bottom: 8px;">
                        <span class="stats-level" style="color: #3b82f6; font-weight: 600;">–£—Ä ${currentLevel} (–≤–∞—à —É—Ä–æ–≤–µ–Ω—å)</span>
                        <span class="stats-count" style="font-weight: 600;">–≤—Å–µ–≥–æ ${filledRootLevelCards}/${totalRootLevelCards}</span>
                    </div>`;
                    
                    htmlRoot += `<div class="stats-item" style="margin-bottom: 8px;">
                        <span class="stats-level" style="color: #3b82f6;">–ü–æ–≤—ã—Å–∏—Ç—å —É—Ä–æ–≤–µ–Ω—å (${nextLevel})</span>
                        <span class="stats-count" style="color: ${needed > 0 ? '#ef4444' : '#22c55e'};">
                            ${partnersAtLevel}/3 —É—Ä ${currentLevel}${needed > 0 ? ` (–Ω–µ —Ö–≤–∞—Ç–∞–µ—Ç: ${needed})` : ' (–≥–æ—Ç–æ–≤ –∫ –ø–æ–≤—ã—à–µ–Ω–∏—é)'}</span>
                    </div>`;
                    
                    requirementDetails.push({
                        forLevel: nextLevel,
                        fromLevel: currentLevel,
                        have: partnersAtLevel,
                        max: 3,
                        need: needed
                    });
                    
                    // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –≤—Å–µ—Ö –ø–∞—Ä—Ç–Ω–µ—Ä–æ–≤ –ø–æ —É—Ä–æ–≤–Ω—è–º (–æ—Ç –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–≥–æ –∫ –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–º—É) –≤ —Ñ–æ—Ä–º–∞—Ç–µ X/Y —É—Ä Z
                    const partnerLevels = Object.keys(partnersByLevel).map(l => parseInt(l)).sort((a, b) => b - a);
                    partnerLevels.forEach(partnerLevel => {
                        const count = partnersByLevel[partnerLevel].size;
                        const max = partnersMaxByLevel[partnerLevel] || 0;
                        if (!requirementsSummary[partnerLevel]) {
                            requirementsSummary[partnerLevel] = { have: 0, max: 0 };
                        }
                        requirementsSummary[partnerLevel].have += count;
                        requirementsSummary[partnerLevel].max += max;
                        // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –≤ —Ñ–æ—Ä–º–∞—Ç–µ X/Y —É—Ä Z
                        htmlRoot += `<div class="stats-item">
                            <span style="color: #6b7280;">${count}/${max} —É—Ä ${partnerLevel}</span>
                        </div>`;
                    });
                    
                    htmlDetails += htmlRoot;
                } else {
                    // –î–ª—è –¥—Ä—É–≥–∏—Ö —É—Ä–æ–≤–Ω–µ–π –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –ø–∞—Ä—Ç–Ω–µ—Ä–∞—Ö –¥–ª—è –ø–æ–≤—ã—à–µ–Ω–∏—è
                    const partnersAtLevel = stats.partnersAtLevel || 0;
                    const needed = stats.neededForNextLevel || 0;
                    const max = stats.max || 0;
                    const targetPartnerLevel = stats.targetPartnerLevel !== undefined ? stats.targetPartnerLevel : (level - 1);
                    const totalCards = stats.total || 0;
                    const filledCards = stats.filled || 0;
                    
                    htmlDetails += `<div class="stats-item" style="margin-bottom: 4px;">
                        <span class="stats-level" style="color: #3b82f6;">–£—Ä ${level}</span>
                        <span class="stats-count" style="font-weight: 600;">–≤—Å–µ–≥–æ ${filledCards}/${totalCards}</span>
                    </div>`;
                    htmlDetails += `<div class="stats-item" style="font-size: 12px; color: ${needed > 0 ? '#ef4444' : '#22c55e'}; margin-bottom: 8px;">
                        <span>–ü—Ä–æ–≥—Ä–µ—Å—Å: ${partnersAtLevel}/${max > 0 ? max : 3} —É—Ä ${targetPartnerLevel}</span>
                        <span>${needed > 0 ? `–Ω–µ —Ö–≤–∞—Ç–∞–µ—Ç: ${needed}` : '–≥–æ—Ç–æ–≤ –∫ –ø–æ–≤—ã—à–µ–Ω–∏—é'}</span>
                    </div>`;
                    
                    const targetLevelKey = targetPartnerLevel;
                    if (!requirementsSummary[targetLevelKey]) {
                        requirementsSummary[targetLevelKey] = { have: 0, max: 0 };
                    }
                    const maxValue = max > 0 ? max : (filledCards.length > 0 ? filledCards.length * 3 : 3);
                    requirementsSummary[targetLevelKey].have += partnersAtLevel;
                    requirementsSummary[targetLevelKey].max += maxValue;
                    
                    requirementDetails.push({
                        forLevel: level,
                        fromLevel: targetPartnerLevel,
                        have: partnersAtLevel,
                        max: maxValue,
                        need: needed
                    });
                }
            }
            
            let htmlSummary = `
                <div class="stats-item" style="font-weight: 600; margin-bottom: 4px;">
                    <span class="stats-level" style="color: #1f2937;">–ü—Ä—è–º—ã–µ / –≤—Å–µ–≥–æ</span>
                    <span class="stats-count" style="color: #1f2937;">${directReferralsRoot}/${totalReferralsRoot}</span>
                </div>
                <div class="stats-item" style="font-size: 12px;">
                    <span class="stats-level" style="color: #4b5563;">–§–∏–Ω–∞–Ω—Å—ã</span>
                    <span class="stats-count">üü° ${formatMoney(bonusYellowRoot)} ¬∑ üî¥ ${formatMoney(transitionRedRoot)} ¬∑ üü¢ ${formatMoney(payoutGreenRoot)}</span>
                </div>
            `;
            if (summaryLevels.length > 0) {
                htmlSummary += `<div class="stats-item" style="font-weight: 600; margin-bottom: 4px;">
                    <span class="stats-level" style="color: #1f2937;">–í—Å–µ–≥–æ –∫–∞—Ä—Ç–æ—á–µ–∫</span>
                    <span class="stats-count" style="color: #1f2937;">${overallTotals.filled}/${overallTotals.total}</span>
                </div>`;
                htmlSummary += `<div class="stats-item" style="font-size: 12px;">
                    <span class="stats-level" style="color: #4b5563;">–í—Å–µ–≥–æ —É—Ä–æ–≤–Ω–µ–π</span>
                    <span class="stats-count" style="color: #4b5563;">${totalLevelsCount}</span>
                </div>`;
                summaryLevels.forEach(item => {
                    htmlSummary += `<div class="stats-item" style="font-size: 12px;">
                        <span class="stats-level" style="color: #4b5563;">–£—Ä ${item.level}</span>
                        <span class="stats-count">${item.filled}/${item.total}</span>
                    </div>`;
                });
            }
            
            let htmlRequirements = '';
            const requirementLevels = Object.keys(requirementsSummary).map(l => parseInt(l)).sort((a, b) => b - a);
            if (requirementLevels.length > 0) {
                htmlRequirements += `<div class="stats-item" style="font-weight: 600; margin-top: 8px;">
                    <span class="stats-level" style="color: #1f2937;">–¢—Ä–µ–±—É–µ—Ç—Å—è –¥–ª—è –ø–æ–≤—ã—à–µ–Ω–∏—è</span>
                </div>`;
                requirementLevels.forEach(levelKey => {
                    const summary = requirementsSummary[levelKey];
                    if (!summary || summary.max === 0) return;
                    const need = Math.max(0, summary.max - summary.have);
                    htmlRequirements += `<div class="stats-item" style="font-size: 12px;">
                        <span class="stats-level" style="color: #4b5563;">—É—Ä ${levelKey}</span>
                        <span class="stats-count" style="color: ${need > 0 ? '#ef4444' : '#22c55e'};">${summary.have}/${summary.max}${need > 0 ? ` (–Ω–µ —Ö–≤–∞—Ç–∞–µ—Ç: ${need})` : ''}</span>
                    </div>`;
                });
            }
            
            let htmlRequirementTransitions = '';
            if (requirementDetails.length > 0) {
                const sortedRequirements = requirementDetails.slice().sort((a, b) => b.forLevel - a.forLevel);
                const focusLevel2 = sortedRequirements.find(item => item.forLevel === 2 && item.fromLevel === 1);
                if (focusLevel2) {
                    htmlRequirementTransitions += `<div class="stats-item" style="font-weight: 600; margin-top: 8px;">
                        <span class="stats-level" style="color: #1f2937;">–ü–µ—Ä–µ—Ö–æ–¥ –Ω–∞ —É—Ä 2</span>
                        <span class="stats-count" style="color: ${focusLevel2.need > 0 ? '#ef4444' : '#22c55e'};">${focusLevel2.have}/${focusLevel2.max}${focusLevel2.need > 0 ? ` (–Ω–µ —Ö–≤–∞—Ç–∞–µ—Ç: ${focusLevel2.need} —É—Ä 1)` : ''}</span>
                    </div>`;
                }
                htmlRequirementTransitions += `<div class="stats-item" style="font-weight: 600; margin-top: 4px;">
                    <span class="stats-level" style="color: #1f2937;">–ü–µ—Ä–µ—Ö–æ–¥—ã —É—Ä–æ–≤–Ω–µ–π</span>
                </div>`;
                sortedRequirements.forEach(item => {
                    const color = item.need > 0 ? '#ef4444' : '#22c55e';
                    htmlRequirementTransitions += `<div class="stats-item" style="font-size: 12px;">
                        <span class="stats-level" style="color: #4b5563;">—É—Ä ${item.forLevel} ‚Üê —É—Ä ${item.fromLevel}</span>
                        <span class="stats-count" style="color: ${color};">${item.have}/${item.max}${item.need > 0 ? ` (–Ω–µ —Ö–≤–∞—Ç–∞–µ—Ç: ${item.need})` : ''}</span>
                    </div>`;
                });
            }
            
            let html = htmlSummary + htmlRequirements + htmlRequirementTransitions + htmlDetails;
            if (html === '') {
                html = '<div class="stats-item">–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö</div>';
            }
            statsContent.innerHTML = html;
        }

        function renderStatsFromServer(stats) {
            if (!statsContent) return;
            if (!stats) {
                statsContent.innerHTML = '<div class="stats-item">–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö</div>';
                return;
            }

            let html = '';
            if (stats.root) {
                html += `<div class="stats-item" style="font-weight:600;">
                    <span class="stats-level" style="color:#1f2937;">${stats.root.name || 'Root'} (—É—Ä–æ–≤–µ–Ω—å ${stats.root.level || 0})</span>
                    <span class="stats-count">${stats.root.direct_referrals || 0} / ${stats.root.total_descendants || 0}</span>
                </div>`;
                html += `<div class="stats-item" style="font-size:12px;">
                    <span class="stats-level" style="color:#4b5563;">–ü–∞—Ä—Ç–Ω–µ—Ä—ã –ø–µ—Ä–≤–æ–π –ª–∏–Ω–∏–∏</span>
                    <span class="stats-count">${stats.root.partners_on_first_line || 0}</span>
                </div>`;
            }

            if (stats.totals) {
                html += `<div class="stats-item" style="font-weight:600; margin-top:8px;">
                    <span class="stats-level" style="color:#1f2937;">–í—Å–µ–≥–æ –≤ —Å—Ç—Ä—É–∫—Ç—É—Ä–µ</span>
                    <span class="stats-count">${stats.totals.nodes || 0}</span>
                </div>`;
                html += `<div class="stats-item" style="font-size:12px;">
                    <span class="stats-level" style="color:#4b5563;">–ü–∞—Ä—Ç–Ω—ë—Ä—ã</span>
                    <span class="stats-count">${stats.totals.partners || 0}</span>
                </div>`;
                html += `<div class="stats-item" style="font-size:12px;">
                    <span class="stats-level" style="color:#4b5563;">–£—á–∞—Å—Ç–Ω–∏–∫–∏</span>
                    <span class="stats-count">${stats.totals.participants || 0}</span>
                </div>`;
            }

            if (Array.isArray(stats.levels) && stats.levels.length > 0) {
                html += `<div class="stats-item" style="font-weight:600; margin-top:8px;">
                    <span class="stats-level" style="color:#1f2937;">–ü–æ —É—Ä–æ–≤–Ω—è–º</span>
                </div>`;
                stats.levels.forEach(levelInfo => {
                    html += `<div class="stats-item" style="font-size:12px;">
                        <span class="stats-level" style="color:#4b5563;">–£—Ä ${levelInfo.level}</span>
                        <span class="stats-count">${levelInfo.total || 0} (${levelInfo.partners || 0} –ø–∞—Ä—Ç.)</span>
                    </div>`;
                });
            }

            if (stats.generated_at) {
                const formatted = new Date(stats.generated_at).toLocaleString();
                html += `<div class="stats-item" style="font-size:11px; color:#6b7280; margin-top:8px;">
                    –û–±–Ω–æ–≤–ª–µ–Ω–æ: ${formatted}
                </div>`;
            }

            statsContent.innerHTML = html || '<div class="stats-item">–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö</div>';
        }

        function ensureDefaultStructure(options = {}) {
            const { depth = DEFAULT_PLACEHOLDER_DEPTH } = options;
            const root = ensureRootCardExists();
            if (!root || depth <= 0) return;

            const createdNodes = [];

            function fillPlaceholders(node, remainingDepth) {
                if (remainingDepth <= 0) return;

                let children = Array.from(canvas.querySelectorAll(`.card[data-parent="${node.dataset.id}"]`));

                while (children.length < 3) {
                    const side = chooseSideForNewChild(node, children);
                    const newChild = createChild(node, side, { skipSave: true, skipStats: true });
                    if (!newChild) break;
                    delete newChild.dataset.name;
                    delete newChild.dataset.uid;
                    newChild.dataset.level = '0';
                    renderCardContents(newChild);
                    children.push(newChild);
                    createdNodes.push(newChild);
                }

                children.forEach(child => fillPlaceholders(child, remainingDepth - 1));
            }

            fillPlaceholders(root, depth);

            if (createdNodes.length > 0) {
                recalculateAllLevels({
                    preserveRootLevel: true,
                    skipSave: true
                });
                savePositions();
                updateAllConnections();
                updateStats();
            }
        }

        // –û—á–∏—Å—Ç–∏—Ç—å —Ç–µ—Å—Ç–æ–≤—ã–µ –¥–∞–Ω–Ω—ã–µ –¥–æ—á–µ—Ä–Ω–∏—Ö –æ–±—ä–µ–∫—Ç–æ–≤ root (—Ç–æ–ª—å–∫–æ –¥–∞–Ω–Ω—ã–µ, –∫–∞—Ä—Ç–æ—á–∫–∏ –Ω–µ —É–¥–∞–ª—è–µ–º)
        async function clearTestData() {
            const rootCard = canvas.querySelector('.card[data-id="root"]');
            if (!rootCard) return;
            
            // –ù–∞—Ö–æ–¥–∏–º –≤—Å–µ –¥–æ—á–µ—Ä–Ω–∏–µ –æ–±—ä–µ–∫—Ç—ã root —Ä–µ–∫—É—Ä—Å–∏–≤–Ω–æ
            function getAllDescendants(parentId) {
                const children = Array.from(canvas.querySelectorAll(`.card[data-parent="${parentId}"]`));
                let allDescendants = [...children];
                children.forEach(child => {
                    allDescendants.push(...getAllDescendants(child.dataset.id));
                });
                return allDescendants;
            }
            
            const rootChildren = getAllDescendants('root');
            
            // –û—á–∏—â–∞–µ–º –¥–∞–Ω–Ω—ã–µ –≤—Å–µ—Ö –¥–æ—á–µ—Ä–Ω–∏—Ö –æ–±—ä–µ–∫—Ç–æ–≤ root
            rootChildren.forEach(card => {
                delete card.dataset.name;
                delete card.dataset.uid;
                card.dataset.level = '0'; // –°–±—Ä–∞—Å—ã–≤–∞–µ–º —É—Ä–æ–≤–µ–Ω—å –Ω–∞ 0
                card.dataset.directReferrals = '0';
                card.dataset.directInvites = '0';
                card.dataset.totalReferrals = '0';
                card.dataset.bonusYellow = '0';
                card.dataset.transitionRed = '0';
                card.dataset.payoutGreen = '0';
                renderCardContents(card);
            });
            
            // –ü–µ—Ä–µ—Å—á–∏—Ç—ã–≤–∞–µ–º —É—Ä–æ–≤–Ω–∏ –≤—Å–µ—Ö –∫–∞—Ä—Ç–æ—á–µ–∫ –ø–æ—Å–ª–µ –æ—á–∏—Å—Ç–∫–∏
            await recalculateAllLevels();
            
            savePositions();
            updateStats();
            
            // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ
            const btn = btnClearTestData;
            const originalText = btn.textContent;
            btn.textContent = '‚úì –û—á–∏—â–µ–Ω–æ!';
            btn.style.background = '#22c55e';
            setTimeout(() => {
                btn.textContent = originalText;
                btn.style.background = '#f59e0b';
            }, 2000);
        }
        
        btnClearTestData.onclick = () => clearTestData();
        btnClearAll.onclick = () => resetToRoot({ seedPlaceholders: true });
        
        async function clearBackendStructure() {
            try {
                const response = await fetch('/admin-panel/api/clear-partners/', {
                    method: 'POST'
                });
                if (!response.ok) {
                    if (response.status !== 404) {
                        console.error('–û—à–∏–±–∫–∞ –æ—á–∏—Å—Ç–∫–∏ –±–∞–∑—ã –ø–∞—Ä—Ç–Ω–µ—Ä–æ–≤:', await response.text());
                    }
                }
            } catch (error) {
                console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—á–∏—Å—Ç–∫–µ –ø–∞—Ä—Ç–Ω–µ—Ä–æ–≤ –≤ –±–∞–∑–µ:', error);
            }
        }
        
        // –£–¥–∞–ª–∏—Ç—å –≤—Å–µ –∫–∞—Ä—Ç–æ—á–∫–∏ –∫—Ä–æ–º–µ root –∏ —Å–±—Ä–æ—Å–∏—Ç—å —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ
        async function resetToRoot(options = {}) {
            const { seedPlaceholders = true } = options;
            await clearBackendStructure();
            
            // –û—á–∏—â–∞–µ–º localStorage –∏ —à–∞–±–ª–æ–Ω—ã, —á—Ç–æ–±—ã –Ω–µ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–∏–ª–∏—Å—å —Å—Ç–∞—Ä—ã–µ –¥–∞–Ω–Ω—ã–µ
            localStorage.removeItem(STORAGE_KEY);
            localStorage.removeItem(LAYOUT_TEMPLATE_KEY);
            localStorage.removeItem(STATS_COLLAPSE_KEY);
            
            // –ù–∞—Ö–æ–¥–∏–º root –∫–∞—Ä—Ç–æ—á–∫—É
            let root = canvas.querySelector('.card[data-id="root"]');
            const rootId = root ? root.dataset.id : null;
            
            // –£–¥–∞–ª—è–µ–º –í–°–ï –∫–∞—Ä—Ç–æ—á–∫–∏ –∫—Ä–æ–º–µ root
            const allCards = Array.from(canvas.querySelectorAll('.card'));
            allCards.forEach(card => {
                if (card && card.dataset.id !== rootId) {
                    card.remove();
                }
            });
            
            // –û—á–∏—Å—Ç–∏—Ç—å –≤—Å–µ —Å–≤—è–∑–∏
            links.innerHTML = '';
            
            // –°–±—Ä–æ—Å–∏—Ç—å —Å–æ—Å—Ç–æ—è–Ω–∏–µ
            childMap.clear();
            uidCounter = 1;
            
            // –í–æ—Å—Å—Ç–∞–Ω–æ–≤–∏—Ç—å root –∫–∞—Ä—Ç–æ—á–∫—É
            root = ensureRootCardExists();
            root.dataset.level = '0';
            root.dataset.parent = '';
            root.dataset.directInvites = '0';
            root.dataset.directReferrals = '0';
            root.dataset.totalReferrals = '0';
            root.dataset.bonusYellow = '0';
            root.dataset.transitionRed = '0';
            root.dataset.payoutGreen = '0';
            renderCardContents(root);
            root.querySelectorAll('.point').forEach(p => p.remove());
            attachPoints(root);
            enableDrag(root);
            
            await saveCardToDatabase(root);

            if (seedPlaceholders) {
                ensureDefaultStructure();
            }
            
            recalculateAllLevels({
                preserveRootLevel: true,
                forceRootLevel: 0,
                skipSave: true
            });
            
            savePositions();
            updateAllConnections();
            updateStats();
            await ensureRootInDatabase();
        }

        function countFilledChildren(card) {
            return Array.from(canvas.querySelectorAll(`.card[data-parent="${card.dataset.id}"]`)).filter(isCardFilled).length;
        }

        function chooseSideForNewChild(parentCard, existingChildren) {
            if (existingChildren.length === 0) return 'middle';
            if (existingChildren.length === 1) {
                const existing = existingChildren[0];
                const parentX = parseInt(parentCard.style.left) || 0;
                const childX = parseInt(existing.style.left) || 0;
                if (childX < parentX) return 'right';
                if (childX > parentX) return 'left';
                return 'left';
            }
            const parentX = parseInt(parentCard.style.left) || 0;
            let leftCount = 0;
            let rightCount = 0;
            existingChildren.forEach(child => {
                const childX = parseInt(child.style.left) || 0;
                if (childX < parentX) {
                    leftCount += 1;
                } else {
                    rightCount += 1;
                }
            });
            return leftCount <= rightCount ? 'left' : 'right';
        }

        function loadDirectInvitesFromLocalStorage() {
            try {
                const saved = localStorage.getItem(STORAGE_KEY);
                if (!saved) return new Map();
                const data = JSON.parse(saved);
                if (!data.cards) return new Map();
                const map = new Map();
                data.cards.forEach(item => {
                    if (!item || !item.id) return;
                    map.set(String(item.id), parseInt(item.directInvites || '0', 10) || 0);
                });
                return map;
            } catch (error) {
                console.warn('Failed to load directInvites from localStorage', error);
                return new Map();
            }
        }
    </script>
</body>
</html>
