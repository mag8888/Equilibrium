<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Структура v2 — Сетка, панорамирование, перетаскивание</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; }
        .toolbar { position: fixed; top: 10px; left: 10px; z-index: 1000; display: flex; gap: 8px; background: rgba(255,255,255,0.9); padding: 8px 10px; border-radius: 8px; box-shadow: 0 2px 12px rgba(0,0,0,0.1); }
        .btn { padding: 6px 10px; border: 1px solid #ddd; background: #fff; border-radius: 6px; cursor: pointer; }
        .viewport { position: relative; width: 100vw; height: 100vh; overflow: hidden; background: #fafafa; }
        .canvas { position: absolute; top: 0; left: 0; width: 5000px; height: 5000px; transform-origin: 0 0; }
        .grid { position: absolute; inset: 0; background-image: linear-gradient(#eee 1px, transparent 1px), linear-gradient(90deg, #eee 1px, transparent 1px); background-size: 40px 40px, 40px 40px; pointer-events: none; }
        .grid.heavy { background-image: linear-gradient(#eee 1px, transparent 1px), linear-gradient(90deg, #eee 1px, transparent 1px), linear-gradient(#e2e8f0 1px, transparent 1px), linear-gradient(90deg, #e2e8f0 1px, transparent 1px); background-size: 40px 40px, 40px 40px, 200px 200px, 200px 200px; }
        .links { position: absolute; inset: 0; pointer-events: none; }
        .link-path { fill: none; stroke: #2563eb; stroke-width: 4; opacity: 0.9; }
        .link-shadow { fill: none; stroke: rgba(37,99,235,0.25); stroke-width: 8; }
        .card { position: absolute; min-width: 140px; min-height: 64px; padding: 10px 12px; background: white; border: 2px solid #cbd5e1; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.06); cursor: grab; user-select: none; transition: box-shadow 0.15s ease; }
        .card:hover { box-shadow: 0 6px 18px rgba(0,0,0,0.1); }
        .card.dragging { cursor: grabbing; z-index: 2000; }
        .point { position: absolute; width: 12px; height: 12px; border-radius: 50%; background: #22c55e; border: 2px solid #16a34a; top: 50%; transform: translateY(-50%); cursor: pointer; }
        .point.left { left: -8px; }
        .point.right { right: -8px; }
        .point.disabled { background: #e5e7eb; border-color: #cbd5e1; cursor: not-allowed; }
    </style>
</head>
<body>
    <div class="toolbar">
        <button class="btn" id="toggleGrid">Скрыть сетку</button>
        <button class="btn" id="center">Центрировать</button>
        <button class="btn" id="snap">Привязка к сетке: Вкл</button>
        <button class="btn" id="zoomOut">−</button>
        <button class="btn" id="zoomIn">+</button>
    </div>
    <div class="viewport" id="viewport">
        <div class="canvas" id="canvas">
            <div class="grid heavy" id="grid"></div>
            <svg class="links" id="links" width="5000" height="5000"></svg>
            <!-- Авто-раскладка примера по уровням -->
            <div class="card" data-id="root" data-level="0" style="left: 2400px; top: 200px;">IVA • Level 0</div>
        </div>
    </div>

    <script>
        const GRID_SIZE = 40;
        const viewport = document.getElementById('viewport');
        const canvas = document.getElementById('canvas');
        const grid = document.getElementById('grid');
        const links = document.getElementById('links');
        const btnGrid = document.getElementById('toggleGrid');
        const btnCenter = document.getElementById('center');
        const btnSnap = document.getElementById('snap');
        const btnZoomIn = document.getElementById('zoomIn');
        const btnZoomOut = document.getElementById('zoomOut');

        let scale = 1; // 0.5..2
        let offsetX = 0; // панорама
        let offsetY = 0;
        let isPanning = false;
        let panStartX = 0, panStartY = 0;
        let canvasStartX = 0, canvasStartY = 0;
        let snapEnabled = true;

        function clampOffsets() {
            const canvasW = 5000 * scale;
            const canvasH = 5000 * scale;
            const minX = Math.min(0, viewport.clientWidth - canvasW);
            const minY = Math.min(0, viewport.clientHeight - canvasH);
            const maxX = 0;
            const maxY = 0;
            offsetX = Math.max(minX, Math.min(maxX, offsetX));
            offsetY = Math.max(minY, Math.min(maxY, offsetY));
        }
        function applyTransform() {
            clampOffsets();
            canvas.style.transform = `translate(${offsetX}px, ${offsetY}px) scale(${scale})`;
        }

        // Панорамирование по пустому месту
        viewport.addEventListener('mousedown', (e) => {
            if (e.target.classList.contains('card')) return;
            isPanning = true;
            panStartX = e.clientX;
            panStartY = e.clientY;
            canvasStartX = offsetX;
            canvasStartY = offsetY;
        });
        window.addEventListener('mousemove', (e) => {
            if (!isPanning) return;
            offsetX = canvasStartX + (e.clientX - panStartX);
            offsetY = canvasStartY + (e.clientY - panStartY);
            applyTransform();
        });
        window.addEventListener('mouseup', () => { isPanning = false; });

        // Зум колёсиком
        viewport.addEventListener('wheel', (e) => {
            e.preventDefault();
            const delta = e.deltaY < 0 ? 1.1 : 0.9;
            const prevScale = scale;
            scale = Math.min(2, Math.max(0.5, scale * delta));
            // Масштаб вокруг курсора
            const rect = viewport.getBoundingClientRect();
            const cx = e.clientX - rect.left;
            const cy = e.clientY - rect.top;
            offsetX = cx - (cx - offsetX) * (scale / prevScale);
            offsetY = cy - (cy - offsetY) * (scale / prevScale);
            applyTransform();
        }, { passive: false });

        btnZoomIn.onclick = () => { scale = Math.min(2, scale * 1.1); applyTransform(); };
        btnZoomOut.onclick = () => { scale = Math.max(0.5, scale * 0.9); applyTransform(); };
        btnCenter.onclick = () => { offsetX = (viewport.clientWidth - 5000 * scale) / 2; offsetY = 120; applyTransform(); };

        // Переключатель сетки
        let gridVisible = true;
        btnGrid.onclick = () => {
            gridVisible = !gridVisible;
            grid.style.display = gridVisible ? 'block' : 'none';
            btnGrid.textContent = gridVisible ? 'Скрыть сетку' : 'Показать сетку';
        };
        btnSnap.onclick = () => {
            snapEnabled = !snapEnabled;
            btnSnap.textContent = `Привязка к сетке: ${snapEnabled ? 'Вкл' : 'Выкл'}`;
        };

        // Вспомогательное: генератор id и работа с детьми
        const childMap = new Map(); // parentId -> Set(childIds)
        let uidCounter = 1;
        function genId() { return 'node-' + (uidCounter++); }
        function getChildSet(parentId) {
            if (!childMap.has(parentId)) childMap.set(parentId, new Set());
            return childMap.get(parentId);
        }
        function updatePointsState(card) {
            const pid = card.dataset.id;
            const count = (getChildSet(pid)).size;
            const disabled = count >= 3;
            card.querySelectorAll('.point').forEach(p => p.classList.toggle('disabled', disabled));
        }
        function attachPoints(card) {
            if (card.querySelector('.point')) return;
            const left = document.createElement('div'); left.className = 'point left'; left.title = 'Добавить слева';
            const right = document.createElement('div'); right.className = 'point right'; right.title = 'Добавить справа';
            left.addEventListener('click', (e) => { e.stopPropagation(); createChild(card, 'left'); });
            right.addEventListener('click', (e) => { e.stopPropagation(); createChild(card, 'right'); });
            card.appendChild(left); card.appendChild(right);
            updatePointsState(card);
        }

        function createChild(parentCard, side) {
            const parentId = parentCard.dataset.id;
            const children = getChildSet(parentId);
            if (children.size >= 3) return; // лимит

            const id = genId();
            const child = document.createElement('div');
            child.className = 'card';
            child.dataset.id = id;
            child.dataset.parent = parentId;
            const px = parseInt(parentCard.style.left) || 0;
            const py = parseInt(parentCard.style.top) || 0;
            const index = children.size; // 0..2
            const horizontalOffset = side === 'left' ? (-240 - index * 160) : (240 + index * 160);
            child.style.left = (px + horizontalOffset) + 'px';
            child.style.top = (py + 200) + 'px';
            child.textContent = `Child ${index + 1}`;
            canvas.appendChild(child);
            attachPoints(child);
            enableDrag(child);
            children.add(id);
            updatePointsState(parentCard);
            updateConnectionFor(child);
        }

        // Drag карточек
        let dragging = null;
        let dragOffsetX = 0, dragOffsetY = 0;
        let startLeft = 0, startTop = 0;

        function toCanvasCoords(clientX, clientY) {
            const rect = viewport.getBoundingClientRect();
            const x = (clientX - rect.left - offsetX) / scale;
            const y = (clientY - rect.top - offsetY) / scale;
            return { x, y };
        }

        function enableDrag(card) {
            attachPoints(card);
            card.addEventListener('mousedown', (e) => {
                if ((e.target).classList && (e.target).classList.contains('point')) return;
                dragging = card;
                dragging.classList.add('dragging');
                const { x, y } = toCanvasCoords(e.clientX, e.clientY);
                startLeft = parseInt(card.style.left) || 0;
                startTop = parseInt(card.style.top) || 0;
                dragOffsetX = x - startLeft;
                dragOffsetY = y - startTop;
                e.preventDefault();
            });
        }

        canvas.querySelectorAll('.card').forEach(enableDrag);

        window.addEventListener('mousemove', (e) => {
            if (!dragging) return;
            const { x, y } = toCanvasCoords(e.clientX, e.clientY);
            const nx = x - dragOffsetX;
            const ny = y - dragOffsetY;
            dragging.style.left = nx + 'px';
            dragging.style.top = ny + 'px';
            updateConnectionsForCardAndRelatives(dragging);
        });
        window.addEventListener('mouseup', () => {
            if (!dragging) return;
            if (snapEnabled) {
                const nx = Math.round((parseInt(dragging.style.left) || 0) / GRID_SIZE) * GRID_SIZE;
                const ny = Math.round((parseInt(dragging.style.top) || 0) / GRID_SIZE) * GRID_SIZE;
                dragging.style.left = nx + 'px';
                dragging.style.top = ny + 'px';
            }
            dragging.classList.remove('dragging');
            const finished = dragging;
            dragging = null;
            if (finished) updateConnectionsForCardAndRelatives(finished);
        });

        // Старт
        btnCenter.click();

        // ----- Связи (как в Miro): гибкие кривые, следуют за карточками -----
        function getAnchorRight(card) {
            const left = parseInt(card.style.left) || 0;
            const top = parseInt(card.style.top) || 0;
            const w = Math.max(card.offsetWidth, 140);
            const h = Math.max(card.offsetHeight, 64);
            return { x: left + w, y: top + h / 2 };
        }
        function getAnchorLeft(card) {
            const left = parseInt(card.style.left) || 0;
            const top = parseInt(card.style.top) || 0;
            return { x: left, y: top + (Math.max(card.offsetHeight, 64) / 2) };
        }
        function pathCubic(start, end) {
            const dx = Math.max(40, Math.abs(end.x - start.x) * 0.5);
            const c1 = { x: start.x + dx, y: start.y };
            const c2 = { x: end.x - dx, y: end.y };
            return `M ${start.x} ${start.y} C ${c1.x} ${c1.y}, ${c2.x} ${c2.y}, ${end.x} ${end.y}`;
        }
        function ensureLinkPath(id) {
            let g = document.getElementById('link-' + id);
            if (!g) {
                g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                g.setAttribute('id', 'link-' + id);
                const shadow = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                shadow.setAttribute('class', 'link-shadow');
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('class', 'link-path');
                g.appendChild(shadow);
                g.appendChild(path);
                links.appendChild(g);
            }
            return g;
        }
        function updateConnectionFor(childCard) {
            const parentId = childCard.dataset.parent;
            if (!parentId) return;
            const parentCard = canvas.querySelector(`.card[data-id="${parentId}"]`);
            if (!parentCard) return;
            const start = getAnchorRight(parentCard);
            const end = getAnchorLeft(childCard);
            const d = pathCubic(start, end);
            const g = ensureLinkPath(childCard.dataset.id);
            g.firstChild.setAttribute('d', d);
            g.lastChild.setAttribute('d', d);
        }
        function updateConnectionsForCardAndRelatives(card) {
            // Обновляем связь к родителю
            updateConnectionFor(card);
            // И связи ко всем детям
            const id = card.dataset.id;
            canvas.querySelectorAll(`.card[data-parent="${id}"]`).forEach(updateConnectionFor);
        }
        function updateAllConnections() {
            canvas.querySelectorAll('.card[data-parent]').forEach(updateConnectionFor);
        }
        // начальное построение (для root детей пока нет)
        updateAllConnections();
    </script>
</body>
</html>


